function [ PSF_crop, roi ] = is_polypsf_crop(PSF, PSF_fused, threshold, apo)% Crop the channel-PSF that make up the poly PSF to a common ROI.%%   PSF_fused is not really a polochromatic PSF, but a simple sum of all of%   the PSFs before cropping. This way they are not offset in relation to%   one another and a common psf ROI can be estimated from them.%    if nargin < 4 || isempty(apo), apo = 1; end     % fraction of PSF maximum that must be exceeded to be included    if nargin < 3 || isempty(threshold), threshold = 1; end     % fraction of PSF maximum that must be exceeded to be included        threshold = min(threshold, 5);    threshold = max(threshold, 0);        % Darken the circumference of the PSF. This is done because the tails of the PSFs often extend beyond the    % support matrix, and in case of GO PSF there are artifacts at the edges that screw up the clipping.    % the window shape was arrived at empirically :)    if(apo)        [x, y] = meshgrid(linspace(-1, 1, size(PSF_fused,1)));        apo = (x.*x+y.*y)/2;                                 apo = exp(-8*pi*apo.*apo.*apo.*apo);        apo = apo/max(apo(:));        apo = apo.^4;        PSF_fused = PSF_fused .* apo;    end        % Implement thresholding of PSF previously done in PSFmetrics.m    % The aim is to suppress wide tails in PSFs of highly aberrated eyes.    % By doing the thresholding here, the OTF reflects the thresholding.    threshold = mean(PSF_fused(:)) + threshold * std(PSF_fused(:));    PSF_bin = PSF_fused > threshold;        blobs = regionprops(PSF_bin, {'Centroid', 'BoundingBox', 'Area'});    [~,largest_blob_idx] = max([blobs.Area]);        bb = blobs(largest_blob_idx).BoundingBox;    cc = floor(blobs(largest_blob_idx).Centroid);        radius_hor = floor(bb(3)/2);    radius_ver = floor(bb(4)/2);        if(radius_hor > radius_ver)        larger = radius_hor;        smaller = radius_ver;    else        larger = radius_ver;        smaller = radius_hor;    end        % Try to build the ROI using the larger of the two dimensions    roi = [cc(1) - larger, cc(1) + larger - 1;           cc(2) - larger, cc(2) + larger - 1];          % See if we're out of bounds. If so, use the smaller dimension    if( sum( roi < 1) > 0 )        roi = [cc(1) - smaller, cc(1) + smaller - 1;               cc(2) - smaller, cc(2) + smaller - 1];            end        PSF_crop = PSF(roi(2,1):roi(2,2), roi(1,1):roi(1,2));    end