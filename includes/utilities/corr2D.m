function [ellipse, semi_line, pc_line, R, conf, S, p_value, lineEqn, ...    ellipseArea, outlierIndex, T2crit, ellipseRadius,RMSE] ...    =corr2D(X, alpha, graphit, linespec, newfig)% CORR2D - compute correlation and display the 1-alpha confidence ellipse% for 2-D data% % Syntax: [ellipse, semi_line, pc_line, R, conf, S, p_value, lineEqn, ...%           ellipseArea, outlierIndex, T2crit, ellipseRadius, RMSE] ...%			= corr2D(X, alpha, graphit, linespec, newfig);%% Input: (note: empty values are legal for all parameters except X)%	X = data matrix.  Each row is an observation, each column is a variable. Must have exactly 2 columns.%	alpha = significance level.  Confidence range of ellipse = 1-alpha. (default = 0.05)%	graphit = 1 to plot results, 0 to suppress plot%	 graphit can be a vector of boolean switches to select specific graphical elements (default = 1)% 	 if graphit(1),  plot the individual data points% 	 if graphit(2),  plot the means% 	 if graphit(3),  plot the probability ellipse% 	 if graphit(4),  plot the confidence ellipse for mean% 	 if graphit(5),  plot the 1st regresson line (x=X(:,1) is independent variable)% 	 if graphit(6),  plot the 2nd regresson line (y=X(:,2) is independent variable)% 	 if graphit(7),  plot the 1st PC axis (line of maximum correlation)% 	 if graphit(8),  plot the 2nd PC axis (orthogonal to PC 1)% 	 if graphit(9),  plot the major axis% 	 if graphit(10), plot the minor axis% 	 if graphit(11), plot the vertical probability range (is different from vertical extent of ellipse)% 	 if graphit(12), plot the horizontal probability range% 	 if graphit(13), add legends & axis labels%    if graphit(14), indicate outliers with filled red circle%   For a simple graph: graphit = zeros(13,1); graphit(1)=1; graphit(7)=1; graphit(13)=1;%	linespec = vector of linespecs for each of the graphical elements described above%	  default linespec = {'ko';'g+';'b--';'k-';'c-';'m-';'r-';'r-';'b-';'b-';'k-';'k-'};%	  set linespec=0 for publication (all black) = {'ko';'k+';'k-';'k-';'k-';'k-';'k-';'k-';'k-';'k-'};%	  set linespec=1 for default values%	newfig = 1 to create a new fig, = 0 to using existing fig from calling program.  default = 1%% Output:%	ellipse = 100x4 matrix of (x,y) data points which display 1-alpha probability ellipse%		in cols 1(x) and 2(y), and confidence ellipse for mean in cols 3(x) and 4(y)%	semi_line = 4-column matrix for plotting the major and minor axes of the ellipse%		cols 1,2 = (x,y) coords for major axis; cols 3,4 = (x,y) coords for minor axis%	pc_line = 4-column matrix for plotting axes defined by principle components%		cols 1,2 = (x,y) coords for 1st PC axis; cols 3,4 = (x,y) coords for 2nd PC axis%	Note that semi-line and pc_line superimpose.  The difference is the range over which the%		lines are plotted, and the method for constructing these lines.% 	R = correlation coefficient.  %	conf = 4x2 matrix of confidence interval data returned by confidence.m%	Two cols correspond to 2 cols of X:%		row 1 = mean of X; row 2 = size of c.i.; %       row 3 = low limit of c.i.; row 4 = high limit of c.i.%		(prior to 26dec02: xbar=mean vector; xbar(1)=mean of col 1 of X;%           xbar(2)=mean of col 2 of X) %	S = covariance matrix%	p_value = significance level of t-statistic for hypothesis that input%       variables are uncorrelated (R = 0) %	lineEqn = 4x2 matrix defining 4 lines.  %		Col 1= slope, col 2 = y-intercept.%		Row 1 = first regression line, %       Row 2 = second regression line%		Row 3 = first PC line = major axis of ellipse, %       Row 4 = second PC line = minor axis of ellipse%	ellipseArea = area of probability ellipse, area of conf. ellipse for mean%   outlierIndex = index to rows of X that lie outside probability ellipse%   T2crit = [T2_table, df1, df2, alpha] used in construction of conf. ellipse%   ellipseRadius = 1x4 vector: probability ellipse, conf. ellipse for mean,%       semi_axis1, semi_axis2%   RMSE = 2x2 matrix of RMS deviation of data from regression models%     row 1 = RMS of y-values from model predictions%     row 2 = RMS of x-values from model predictions%     col 1 = regression models%     col 2 = PCA model%	% see also:  test_corr2D.m% this program calls several routines in Matlab's statistics toolbox.%% LNT 20 Nov 01. % LNT 31Mar02, correct the plotting of regression lines.% LNT 31Jul02, correct a small error in finding axis limits for plotting % LNT 8-Nov-02 tidy up graphics a bit% LNT 21-Nov-02.  Add lineEqn to output variables and newfig to input variables.% LNT 26Dec02.  Add areaEllipse to output variables; changed 5th output arg from "xbar" to "conf".% LNT 27Mar05. Use cell array for legend. Matlab 7 won't allow empty arguments to "Legend"% LNT 21Nov05. Made ellipseArea a vector with second element = area of%   confidence ellipse on the mean, which has area scaled by 1/n. Also%   added outlier analysis to locate points outside 95% prob ellipse.% LNT 26Mar06. Add T2crit to list of output variables. Revise plotting of%   outliers with the help of new routine T2outliers% LNT 25Jun07. Add ellipseRadius to output variables.% LNT 25-Sep-08.  Add RMSE analysis (uses an internal function).% LNT 15-Dec-2010. Add plotting of horizontal & vertical error bars for data points.%% Notes: Textbooks by Anderson and Krzanowski describe a confidence ellipse for the mean%	vector based on T^2/n.  Jackson's book builds a "probability ellipse" to capture 95%%	of the data, based on T^2.  This difference is equivalent to the difference between %	using StDev to describe the range of a variable, and SEM to describe confidence interval%	for the mean of that variable.%  Method is to introduce a change of variables into Jackson's eqn. 1.7.2 that centers the %  	data on the mean vector. Let the true population mean be the unknowns x,y and solve for y%  	in terms of x using the quadratic formula.  Jackson describes a slightly different approach%	in his chapter 15.%  Note that R is computed from the covariance matrix, which is symmetric because %   the covariance of (x,y) = covariance (y,x).   This means that the value of R is %   independent of the choice to regress x on y, or y on x, or orthogoinal regression.%  Orthogonal regressions computed using covariance matrix are sensitive to%   scale (i.e. units) anc variance of input data in cols of X. An alternative method%   using correlation matrix instead of covariance matrix in PCA analysis%   is equivalent (according to Jackson) of normalizing input data into%   z-scores, and then inverting that scaling for resulting PCs to get slope. %%  For future work, compute confidence intervals for regression slopes.if nargin < 5, newfig = 1; endif isempty(newfig), newfig = 1; end; if nargin < 4 | isempty(linespec) | char(linespec(1))==1, 	linespec = {'ko';'gx';'k--';'k-';'b-';'b--';'r-';'r--';'b:';'b:';'k-';'k-'};end% if isempty(linespec), % 	linespec = {'go';'kx';'k--';'k-';'b-';'b--';'r-';'r--';'b:';'b:';'k-';'k-'};endif char(linespec(1))==0	linespec = {'ko';'kx';'k--';'k-';'k-';'k-';'k-';'k-';'k-';'k-';'k-';'k-'};% elseif char(linespec(1))==1% 	linespec = {'go';'kx';'k--';'k-';'b-';'b--';'r-';'r--';'b:';'b:';'k-';'k-'};end	if nargin < 3 || isempty(graphit), graphit = ones(1,14);end		% default is to show all graphical resultsif numel(graphit)==1, graphit = graphit*ones(1,14);	end	% expand scalar input to a vector of valuesif length(graphit)<14, graphit(14)=0; end  % for backwards compatibility with calling programs written before 21Nov05    if nargin<2 || isempty(alpha), alpha = 0.05; end	% default is a 95% confidence ellipse[n,p] = size(X);				% n rows (observations), p columns (variables)if p == 2    ebars = false;   % set a flag - no error bars for these dataelseif p == 4    ebars = true;   % set a flag    ebarX = X(:,3); % semi-length of horizontal error bars    ebarY = X(:,4); % semi-length of vertical error bars    X = X(:,1:2);   % strip off the error bar dataelse    error ('Data matrix must have exactly 2 or 4 columns')end[n,p] = size(X);				% n rows (observations), p columns (variables)df1 = p;						% lesser degrees of freedomdf2 = n-p;						% greater degrees of freedomprob = 1 - alpha;				% confidence levelF_table = finv(prob,df1,df2);	% Fisher's F-statisticT2_table = p*(n-1)*F_table/(n-p);		% Hotelling's T-squared statisticT2crit = [T2_table, df1, df2, alpha]; % critical value of T^2, etc.% xbar = mean(X);					% row vector of col meansK = T2_table;							% Jackson, p. 23, eqn 1.7.5[ci xbar lo hi]=confidence(X,1,alpha,0) % univariate probability intervals for meansconf = [xbar; ci; lo; hi];% probability ellipse is the numerical solution to a quadratic equationS = cov(X);						% covariance matrixSinv = inv(S);a = Sinv(1,1); b = Sinv(1,2); c = Sinv(2,1); d = Sinv(2,2);xmax =  sqrt(4*d*K/(4*d*a-(b+c)^2));	% largest x-value on the ellipsex = [-1:.02:1]*xmax;yplus = ( -(b+c)*x + sqrt(x.^2*(b+c)^2 -4*d*(a*x.^2-K)) )/(2*d);	% upper half ellipseyminus = ( -(b+c)*x - sqrt(x.^2*(b+c)^2 -4*d*(a*x.^2-K)) )/(2*d);	% lower half ellipseyplus = real(yplus); yminus = real(yminus);		% strip off any tiny imaginary partsxx = xbar(1) - [x, fliplr(x)];yy = xbar(2) - [yplus, fliplr(yminus)];ellipse = [xx; yy]';			% col 1 = x-coords, col 2 = y-coords% construct two regression lines through the mean point (see Thomasian, p. 460)% the regression lines intersect ellipse at points whose tangents are vertical and horizontalR = S(1,2)/sqrt(S(1,1)*S(2,2));					% get correlation coefficient R_line(:,1) = [xbar(1)-xmax; xbar(1)+xmax];Rslope = sqrt(S(2,2)/S(1,1))*R;	% slope of first regression line (y on x)disp(['Slope of first regression line =',num2str(Rslope)])lineEqn(1,1) = Rslope; lineEqn(1,2) = xbar(2)-Rslope*xbar(1);	% save slope, intercept for first regression lineR_line(:,2) = [xbar(2)-Rslope*xmax; xbar(2)+Rslope*xmax];Rslope = sqrt(S(2,2)/S(1,1))/R;	% slope of second regression line (x on y)disp(['Slope of second regression line =',num2str(Rslope)])lineEqn(2,1) = Rslope; lineEqn(2,2) = xbar(2)-Rslope*xbar(1);	% save slope, intercept for second regression lineR_line(:,3) = [xbar(2)-Rslope*xmax; xbar(2)+Rslope*xmax];% test null hypothesis that the input variables are uncorrelated (rho = 0)% (see Krzanowski, "Principles of Multivariate analysis", p. 414-415t = R*sqrt((n-2)/(1-R^2))alpha=0.05; Student_t = tinv(1-alpha/2,n-2); % two-sided test since rho could be positive or negativeif abs(t) > Student_t, disp('Correlation IS significant at alpha=0.05 level (two-sided)')else, disp('Correlation IS NOT significant at alpha=0.05 level (two-sided)')end	p_value = 2*(1-tcdf(abs(t),n-2))	% prob. of false rejection of null hypothesis (2-sided)% construct principle component axes through the mean point[pc, score, latent] = princomp(X);slope1 = pc(2,1)/pc(1,1),  slope2 = pc(2,2)/pc(1,2)lineEqn(3,1) = slope1; lineEqn(3,2) = xbar(2)-slope1*xbar(1);	% save slope, intercept for first PC linelineEqn(4,1) = slope2; lineEqn(4,2) = xbar(2)-slope2*xbar(1);	% save slope, intercept for second PC linedatamax = max(X(:,1));	datamin = min(X(:,1));		% let line span the datapc_line(:,1) = [datamin; datamax];pc_line(:,2) = [xbar(2)-slope1*(xbar(1)-datamin); xbar(2)+slope1*(datamax-xbar(1))];pc_line(:,3) = [datamin; datamax];pc_line(:,4) = [xbar(2)-slope2*(xbar(1)-datamin); xbar(2)+slope2*(datamax-xbar(1))];% compute RMS for deviation of data from regression linesRMSE = getRMSE(X,lineEqn);% construct major & minor axes of ellipse (redundant, but uses slightly different method)% note: area of ellipse = pi*prod(semiaxes) = pi*semi_axis1*semi_axis2%	=pi*((semi_line(2,1)-semi_line(1,1))^2 + semi_line(2,2)-semi_line(1,2))^2)/4cos_theta1 = pc(1,1)/sqrt(pc(:,1)'*pc(:,1));	% angle between major axis and horizontalsemi_axis1 = sqrt(K*latent(1));				% length of semiaxis (Jackson, p. 343)	dx = semi_axis1*cos_theta1;	dy = slope1*dx;		% resolve semimajor axis onto x,y axessemi_line(:,1) = [xbar(1)-dx; xbar(1)+dx];		% x-coords of two endpoints of linesemi_line(:,2) = [xbar(2)-dy; xbar(2)+dy];		% y-coords of two endpoints of linecos_theta2 = pc(1,2)/sqrt(pc(:,2)'*pc(:,2));	% repeat above steps for minor axissemi_axis2 = sqrt(K*latent(2));dx = semi_axis2*cos_theta2;	dy = slope2*dx;semi_line(:,3) = [xbar(1)-dx; xbar(1)+dx];semi_line(:,4) = [xbar(2)-dy; xbar(2)+dy];ellipseArea = pi*semi_axis1*semi_axis2;ellipseRadius = sqrt(semi_axis1*semi_axis2);    % geometric mean of principle radiidisp(['area of ellipse = ',num2str(ellipseArea)])disp(['geom. mean radius of ellipse = ',num2str(ellipseRadius)])% the following alternative method gives same answer% area_ellipse = pi*sqrt( (semi_line(2,1)-semi_line(1,1))^2 + (semi_line(2,2)-semi_line(1,2))^2 )...% 	*sqrt( (semi_line(2,3)-semi_line(1,3))^2 + (semi_line(2,4)-semi_line(1,4))^2 )/4; % build a second ellipse for confidence bound on the mean vectorK = T2_table/n;		% Anderson,p 165, eqn(10); Krzanowski, eqn (8.1, 8.9)xmax =  sqrt(4*d*K/(4*d*a-(b+c)^2));	% largest x-value on the ellipsex = [-1:.02:1]*xmax;yplus = ( -(b+c)*x + sqrt(x.^2*(b+c)^2 -4*d*(a*x.^2-K)) )/(2*d);	% upper half ellipseyminus = ( -(b+c)*x - sqrt(x.^2*(b+c)^2 -4*d*(a*x.^2-K)) )/(2*d);	% lower half ellipseyplus = real(yplus); yminus = real(yminus);		% strip off any tiny imaginary partsxx = xbar(1) - [x, fliplr(x)];yy = xbar(2) - [yplus, fliplr(yminus)];ellipse(:,3) = xx';								% col 3 = x-coords, col 4 = y-coordsellipse(:,4) = yy';	% since semi_axis1 and semi_axis2 are proportional to sqrt(K), scaling K% by n reduces both semi axis lengths by factor 1/sqrt(n), so ellipse area% scales by 1/nellipseArea(2) = ellipseArea(1)/n;ellipseRadius(2) = ellipseRadius(1)/sqrt(n);    % geometric mean of principle radiiellipseRadius(3) = semi_axis1;  % return these results to calling programellipseRadius(4) = semi_axis2;% find index to outliers = points outside 95% prob ellipseif 0    % this is the brute force method replaced on 26-Mar-06    cos_theta1 = pc(1,1)/sqrt(pc(:,1)'*pc(:,1));	% angle between major axis and horizontal    sin_theta1 = pc(2,1)/sqrt(pc(:,1)'*pc(:,1));	% angle between major axis and vertical    Mrotate = [cos_theta1, sin_theta1; -sin_theta1, cos_theta1];    XX=X;    XX(:,1) = XX(:,1) - xbar(1); % center data on its mean    XX(:,2) = XX(:,2) - xbar(2);     Xrotate = Mrotate*XX';       % rotate data so major axis is horizontal    mag=semi_axis2/semi_axis1;  % scale factor for x-axis to make ellipse a circle    radiusSquared = (mag*Xrotate(1,:)).^2 + Xrotate(2,:).^2; %radius of each data point            % in a scaled coordinate system    outlierIndex = find(radiusSquared > semi_axis2.^2); % points outside the ellipseelseif size(X,1)<1e4    % outlierIndex presents an unknown limit to the size of X    outlierIndex = T2outliers(X,S,conf(1,:),T2crit); % rownumbers of outlierselse    outlierIndex = [];end%keyboardif sum(graphit) == 0, return, end	% quick exit%% do the graphics% m=[max(X); min(X); max(ellipse(:,1:2)); min(ellipse(:,1:2))];	% mmin = min(min(m)); mmax = max(max(m));% k=[mmin-0.1*abs(mmin), mmax+0.1*abs(mmax)]; k=[k,k]ct=0;if newfig, figure, end if graphit(1)    if ~ebars    	hand = plot(X(:,1),X(:,2),char(linespec(1))); 			% plot the data        set(hand,'LineWidth', 2); % use heavier line for publication        % set(hand,'MarkerFaceColor','k'); % use closed symbols    else%    e = 0.05*ones(size(X(:,1)));%    errorbar(X(:,1),X(:,2),e,e,char(linespec(1)),'MarkerFaceColor','k'); 				    hand=errorYbar(X(:,1),X(:,2),ebarY,char(linespec(1))); % plot the data with vertical error bars    set(hand,'MarkerFaceColor','k'); % errorYbar can't fill the symbols    hold on; errorXbar(X(:,1),X(:,2),ebarX,char(linespec(1))); % plot the horizontal error bars    end	hold on; ct=ct+1; leg(ct)={'raw data'}; endif graphit(2)	hand2=plot(xbar(1),xbar(2),char(linespec(2)),'MarkerSize',8, 'LineWidth', 2); 			% plot the means, with emphasis     set(hand2,'MarkerFaceColor','k'); % use closed symbol	hold on; ct=ct+1; leg(ct)={'mean vector'}; end	if graphit(3)	plot(ellipse(:,1),ellipse(:,2),char(linespec(3))); 	% plot the probability ellipse	hold on; ct=ct+1; leg(ct)={'probability ellipse for data'}; end		m=[max(X); min(X); max(ellipse(:,1:2)); min(ellipse(:,1:2))];		mmin = min(min(m)); mmax = max(max(m));	k=[mmin-0.1*abs(mmin), mmax+0.1*abs(mmax)]; k=[k,k]if graphit(4)	plot(ellipse(:,3),ellipse(:,4),char(linespec(4)), 'LineWidth', 2)	% plot the confidence ellipse for mean	hold on; ct=ct+1; leg(ct)={'confidence ellipse for mean'}; endif graphit(5)	plot(R_line(:,1),R_line(:,2),char(linespec(5)))		% plot 1st regresson line	hold on; ct=ct+1; leg(ct)={'1st regression line (y on x)'}; endif graphit(6)	plot(R_line(:,1),R_line(:,3),char(linespec(6)))		% plot 2nd regresson line	hold on; ct=ct+1; leg(ct)={'2nd regression line (x on y)'}; endif graphit(7)	plot(pc_line(:,1),pc_line(:,2),char(linespec(7)),'LineWidth', 2)	% plot 1st PC axis	hold on; ct=ct+1; leg(ct)={'1st principle component axis'}; endif graphit(8)	plot(pc_line(:,3),pc_line(:,4),char(linespec(8)))	% plot 2nd PC axis	hold on; ct=ct+1; leg(ct)={'2nd principle component axis'}; endif graphit(9)	plot(semi_line(:,1),semi_line(:,2),char(linespec(9))) % plot major axis of probability ellipse	hold on; ct=ct+1; leg(ct)={'major axis'}; endif graphit(10)	plot(semi_line(:,3),semi_line(:,4),char(linespec(10))) % plot minor axis of probability ellipse	hold on; ct=ct+1; leg(ct)={'minor axis'}; endif graphit(11)	plot([lo(1) hi(1)],[xbar(2) xbar(2)],char(linespec(11))) % plot vertical c.i.	hold on; ct=ct+1; leg(ct)={'prob range for y'}; endif graphit(12)	plot([xbar(1) xbar(1)],[lo(2) hi(2)],char(linespec(12))) % plot horizontal c.i.	hold on; ct=ct+1; leg(ct)={'prob range for x'}; endif graphit(14)	% highlight outliers	ct=ct+1; leg(ct)={'outliers'}; end% hold off;  % why bother to turn off?if (graphit(3)+graphit(4) >0), axis square, axis(k); endif graphit(14)  % show the outliers    if 0  % the old graphics replaced 26-Mar-06        centeredEllipse = ellipse(:,1:2); % get the prob ellipse        centeredEllipse(:,1) = centeredEllipse(:,1) - xbar(1); % center ellipse        centeredEllipse(:,2) = centeredEllipse(:,2) - xbar(2);         ellipseRotate = Mrotate*centeredEllipse';        figure;     %     subplot(1,2,1);    %     plot(XX(:,1),XX(:,2),'k.'); axis equal    %     hold on;     %     plot(ellipse(:,1),ellipse(:,2),'r-');     %     hold off    %     subplot(1,2,2)        plot(mag*Xrotate(1,:),Xrotate(2,:),'k.'); axis equal        hold on;         plot(mag*ellipseRotate(1,:),ellipseRotate(2,:),'g-');         plot(mag*Xrotate(1,outlierIndex),Xrotate(2,outlierIndex),'ro');         hold off        title('Stretched and rotated coordinate frame')    else    % indicate outliers with filled red circles        hold on        plot(X(outlierIndex,1), X(outlierIndex,2),'ro','MarkerFaceColor', 'r')        hold off    endendif graphit(13)% 	legend('raw data', 'mean vector', 'probability ellipse for data', 'confidence ellipse for mean', ...% 			'1st regression line','2nd regression line','1st principle component axes', ...% 			'2nd principle component axes','major axis','minor axis','prob range for y','prob range for x')	legend(leg)	xlabel('Variate #1'); ylabel ('Variate #2'); % legends & axis labels for a complete plot of all elementsend% and report some scalar values	disp(['mean(x) = ',num2str(xbar(1)),';  mean(y) = ',num2str(xbar(2)),...    ';  # points = ',num2str(n)]);disp(['Correlation coefficient = ',num2str(R),'; p-value =',num2str(p_value)]);disp(['Slope of 1st principle component = ',num2str(slope1)]);disp(['Slope of 2nd principle component = ',num2str(slope2)]);function RMSE = getRMSE(X,lineEqn)% Internal function to residual errors% RMSE = 2x2 matrix of RMS deviation of data from regression models%   row 1 = RMS of y-values from model predictions%   row 2 = RMS of x-values from model predictions%   col 1 = regression models%   col 2 = PCA model% LNT 26-Sep-08% compute RMS for deviation of y-values from 1st regression line% i.e. use x-values to predict y(x)=mx+by = X(:,2);     % the datax = X(:,1);     srN = sqrt(length(x));yModel = lineEqn(1,1)*x + lineEqn(1,2); % use regression line 1 as the modelRMSE(1,1) = norm(y-yModel)/srN;    % based on vertical discrepancy between data and modelyModel2 = lineEqn(3,1)*x + lineEqn(3,2); % use PCA line 1 as the modelRMSE(1,2) = norm(y-yModel2)/srN;    % mean vertical discrepancy between data and model% compute RMS for deviation of x-values from 2nd regression line% i.e. use y-values to predict x(y)=(y-b)/mxModel = (y-lineEqn(2,2))/lineEqn(2,1); % use regression line 2 as the modelRMSE(2,1) = norm(x-xModel)/srN;    % mean horizontal discrepancy between data and modelxModel2 = (y-lineEqn(3,2))/lineEqn(3,1); % use PCA line 1 as the modelRMSE(2,2) = norm(x-xModel2)/srN;    % mean horizontal discrepancy between data and model% diagnostic graphicsdiagnostic=false;if diagnostic    figure;     plot(x,y,'bo',x,yModel,'k-o')    title('First regression: y on x'); xlabel('x'); ylabel('y')    figure;     plot(x,y,'bo',x,yModel2,'k-o')    title('First regression: y on PCAline'); xlabel('x'); ylabel('y')    figure;    plot(x,y,'bo',xModel,y,'k-o')    title('Second regression: x on y'); xlabel('x'); ylabel('y')    figure;    plot(x,y,'bo',xModel2,y,'k-o')    title('Second regression: x on PCAline'); xlabel('x'); ylabel('y')end