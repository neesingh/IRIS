function [Fx,Fy,Fxx,Fyy,Fxy] = gradient2(f,d)%GRADIENT2 - first and second derivatives of a 2D matrix%% usage: [Fx,Fy,Fxx,Fyy,Fxy] = gradient2(f,d)%% This is strictly for 2D matrices on an evenly spaced grid.  A more% general solution, like that used in gradient.m and del2.m, could be% written when the need arises. %% Fx,Fy agree with the output of gradient.m%% input:%	f = source matrix to be differentiated%	d = spacing constant between sample points (default = 1)%% output:%   Fx = dF/dx%   Fy = dF/dy%   Fxx = d^2F/dx^2%   Fyy = d^2F/dy^2%   Fxy = d^2F/dxdy%%  LNT Note:  GRADIENT.m takes differences between rows n+1 & n-1 and%  assigns the result to row n.  Similarly, del2 takes differences between%  row n and the average of rows n-1 & n+1 and assigns the result to row n.%% Formulas for second derivatives were provided by Kobe Rubinstein, IU Math% Dept., which he derived from Taylor series expansion of F. The idea is to% evaluate the Taylor series for right and left sides, take the difference,% and solve for the second derivative in terms of the values of F.  The 1st% and 3rd derivatives drop out by cancellation. Error is on the order of% 4th derivative. %% LNT 9Jul03.  Based on Mathworks' gradient.m  and del2.m which give% efficient code that uses index listing (instead of nested for-loops) to% cycle through the data. %% © 2003 Larry Thibos, Indiana University% 29Jan05. replace isvector with isscalar to be compatible with Matlab 7if nargin < 2, d=1; end		% default if ~isscalar(d), error('Input parameter d must be a scalar'); endif ndims(f)~=2, error('Input matrix must be a 2-dimensional array'); end% Loop over each dimension. Permute/transpose so that the gradient is% always taken along the columns (I.E. BETWEEN ROWS (LNT)).ndim = 2;% do the first derivative (gradient)for k = 1:ndim   [n,p] = size(f);   g  = zeros(size(f)); % case of singleton dimension   % Take forward differences on first and last rows   if n > 1      g(1,:) = (f(2,:) - f(1,:))/d;      g(n,:) = (f(n,:) - f(n-1,:))/d;   end   % Take centered differences on interior points   if n > 2      g(2:n-1,:) = (f(3:n,:)-f(1:n-2,:))/(2*d);   end   if k==1, Fy=g;	% first pass is dF/dy   else,	Fx=g';	% second pass is dF/dx   end   f = f';			% take differences the other wayend % do the second derivatives (change in gradient)for k = 1:ndim   g  = zeros(size(f)); % case of singleton dimension   % Take centered second differences on interior points to compute g/2   if n > 2      g(2:n-1,:)=( (f(3:n,:)-f(2:n-1,:)) - (f(2:n-1,:)-f(1:n-2,:)) ) / d^2;   end   % Linearly extrapolate second differences from interior   if n > 3      g(1,:) = 2*g(2,:) - g(3,:);      g(n,:) = 2*g(n-1,:) - g(n-2,:);   elseif n==3      g(1,:) = g(2,:);      g(n,:) = g(2,:);   else      g(1,:)=0;      g(n,:)=0;   end   if k==1, Fyy=g;	% first pass is d^2F/dy^2   else,	Fxx=g';	% second pass is d^2F/dx^2   end   f = f';			% take differences the other wayend % do the mixed second derivative (cross gradient, Fxy)g  = zeros(size(f)); % case of singleton dimensionif n > 2   % Take centered second differences on interior points to compute g/2   g(2:n-1,2:p-1) = ( f(3:n,3:p) + f(1:n-2,1:p-2) - f(3:n,1:p-2) ...         - f(1:n-2,3:p) ) / (4*d^2);end% Linearly extrapolate second differences from interiorif n > 3  g(1,:) = 2*g(2,:) - g(3,:);  g(n,:) = 2*g(n-1,:) - g(n-2,:);elseif n==3  g(1,:) = g(2,:);  g(n,:) = g(2,:);else  g(1,:)=0;  g(n,:)=0;endif p > 3  g(:,1) = 2*g(:,2) - g(:,3);  g(:,p) = 2*g(:,p-1) - g(:,p-2);elseif p==3  g(:,1) = g(:,2);  g(:,p) = g(:,2);else  g(:,1)=0;  g(:,p)=0;endFxy=g;	% result is d^2F/dxdy