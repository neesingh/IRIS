function [f,MTF_1D, fx,fy,MTF_2D,fc] = DiffractionMTF(pupil,lambda,fmax,fstep)% DiffractionMTF - Compute the diffraction-limited MTF for monochromatic light%% Use: [f,MTF_1D, fx,fy,MTF_2D,fc] = DiffractionMTF(pupil,lambda,fmax,fstep)%% Input args:%	pupil = pupil diameter, same units as lambda%	lambda = wavelength, same units as pupil - only their ratio matters%	fmax = maximum spatial frequencies to use for evaluating the MTF, in cyc/deg%	If fmax is a vector, use it to define a support meshgrid & ignore fstep%	fstep = step size for frequency axis, in cyc/deg. enter 0 to use default%% Output variables:%%	f = support for MTF_1D%	MTF_1D = a radial cross-section of the MTF for positive freq. only.  Negative%				freq. would give the same shape (i.e. basis functions are complex%				exponentials, not sine waves)%	fx,fy = support mesh for MTF_2D%	MTF_2D = the radially-symmetric, 2-dimensional MTF%	fc = cutoff spatial frequency in cyc/deg%% Method is from Goodman, 1968, p. 120%% LNT 14-May-2001% LNT 27-Feb-03. Fix problem created by OTFMetrics.m  by re-defining the meaning of fmax.%	Now, if fmax is a vector, use it for f & ignore fstep% LNT 25-Jun-03.  Mask 1D MTF in the same way as for 2D MTF%% © 2001, 2003 Larry Thibos, Indiana Universityfc = (pupil/lambda/1.22)*(pi/180);	% cutoff spatial freq. in c/dif length(fmax) >1	f = fmax;					% user supplied the support frequencieselse    fstep=1;	f = [-fmax:fstep:fmax-fstep]; 	% calculate 2-sided vector of spatial frequenciesend% do the 1-D casefn = abs(f/fc);					% normalized to cutoffMask = fn<=ones(size(fn));	% mask off normalized frequencies greater than onefn = fn.*Mask;MTF_1D = (2/pi)*( acos(fn) - fn.*sqrt(1-fn.^2) );MTF_1D = Mask.*MTF_1D;%f2 = [-fmax:fstep:fmax];	% 2-D vector of spatial frequencies[fx,fy]=meshgrid(f);		% support for 2-D MTFfr = sqrt(fx.^2 + fy.^2)/fc;	% matrix of normalized radial spatial frequencies	Mask = fr<=ones(size(fx));	% mask off normalized frequencies greater than onefx = fx.*Mask;fy = fy.*Mask;fr = fr.*Mask;MTF_2D = (2/pi)*( acos(fr) - fr.*sqrt(1-fr.^2) );MTF_2D = Mask.*MTF_2D;% end of DiffractionMTF.m