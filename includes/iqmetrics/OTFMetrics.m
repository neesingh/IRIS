function [R,DLnorm,RI_MTF,WI_MTF,WI_OTF,CSF,sfCSF]=OTFMetrics(OTF,X,Y, PupilDia, ...    lambda, showit, doit, objectContrast);% OTFMetrics - compute measures of quality for an Optical Transfer Function%% syntax: [R,DLnorm,RI_MTF,WI_MTF,WI_OTF,CSF,sfCSF]=OTFMetrics(OTF,X,Y, ...%    PupilDia, lambda, showit, doit, objectContrast);%% input args:%   OTF = Optical Transfer Function (origin centered in array)%   X,Y = support mesh for OTF (cyc/deg).  %	PupilDia = pupil diameter%	lambda = wavelength of light%   	Note:  units for PupilDia and lambda must be the same%	showit = boolean switch to turn graphics on.  %       0=default=skip graphics; 1=show graphics%	doit = boolean vector of switches indicating which metrics to compute.  %       default = ones(8,1)%   objectContrast = contrast of object gratings. default = 1.0%% output row vector is:%    R(1) = SFcMTF: SFcutoff for rMTF%    R(2) = AreaMTF: area of visibility for rMTF (normalized to DL case)%    R(3) = SFcOTF: SFcutoff for rOTF%    R(4) = AreaOTF: area of visibility for rOTF (normalized to DL case)%    R(5) = SROTF: volume under OTF/ volume under diffraction-limited OTF %         = Strehl Ratio by OTF method%    R(6) = VOTF: volume under OTF/ volume under MTF %	 R(7) = VSOTF: volume under nCS-weighted OTF/ volume under nCS-weighted DL-OTF%         = Visual Strehl Ratio computed by OTF method. %    R(8) = VNOTF: volume under nCS-weighted OTF/ volume under nCS-weighted MTF %    R(9) = SRMTF: volume under MTF/ volume under diffraction-limited MTF %         = Strehl Ratio by MTF method.  Note that Strehl ratio computed by %           MTF method = SR for a hypothetical PSF computed assuming PTF=0% 	 R(10) = VSMTF: visual Strehl ratio computed by MTF method.  This is VSR for a%           hypothetical PSF computed assuming PTF = 0.%  DLnorm = the diffraction-limited normalizations. To un-normalize the%    metrics, multiply Y.*DLnorm  This may be useful when comparing pupils %    of different sizes.%	RI_MTF = uniformly-spaced spatial-frequency (cyc/deg) row-vector for WI_MTF%   WI_MTF = radial average MTF interpolated onto sampling points RI_MTF%   WI_OTF = radial average OTF interpolated onto sampling points RI_MTF%   CSF - the predicted contrast sensitivity function%   sfCSF - the vector of spatial frequencies (cyc/deg) supporting CSF%% Note that for polychromatic OTFs, the diffraction-limited comparison is% the monochromatic OTF computed for wavelength=lambda, pupil=PupilDia.%%% R(1) and R(3) define cutoff SF as the intersection of MTF and neural%   threshold. An earlier example of this idea is found in Thibos, JOSA-A%   4:1673 (1987).% R(2) and R(4) use enveloped area between MTF and neural threshold as a%   metric of image quality. This idea goes back to Charman & Olin (1965).%   See Ch 2 of "Visual Instrumentation" by Mouroulis for refs.% When computing area under radial MTF, phase-reversed segments of the%   curve count as positive area. In this case it makes sense to define%   cutoff as the highest SF for which rMTF exceeds neural theshold.%   This permits "spurious resolution" to be counted as beneficial for the%   task of contrast detection.% When computing area under radial OTF, spatial phase errors lead to%   negative areas. Now it makes sense to define cutoff as the lowest SF for%   which rOTF is below neural threshold. This permits spurious resolution %   to be discounted for tasks of spatial resolution & pattern discrimination.% R(5) is the correct way to compute Strehl ratio in the frequency domain%   based on central ordinate theorem.  A common error is to compute SR as%   volume under MTF, but this is wrong in principle because MTF=|OTF|.  %   This non-linear transformation destroys the Fourier-transform%   relationship between PSF and OTF that is the basis of central ordinate%   theorem, which in turn is the justification for computing SR in the%   frequency domain. % R(6) was conceived by LNT in August 2002 as a metric that would be%   sensitive to spatial phase shifts.  It was	inspired by a measure%   called "Bias" developed by Thibos & Levick (Exp. Brain Research,%   58:1-10, 1985) for describing orientation bias in the receptive fields%   of retinal ganglion cells.% R(7) and R(8) were conceived by LNT in mid-November, 2002 as variants of%   R(5) and R(6) that take neural contrast sensitivity into account. Note%   that the denominator of R(7) is the volume under the detection CSF%   for an observer with Campbell & Green's neural system and perfect%   optics. Denominator of R(8) is the volume under the detection CSF for%   an observer with Campbell & Green's neural system and their own optics. %   Ideally, we would like to use the subject's own neural CS fn, if known.%   R(7) is called "visual Strehl".% R(8) is a mouthful.  A brief name would be helpful.%	Computing VSR=R(7) in frequency domain will be in error for displaced%	PSFs because the neural CSF has no phase component (corresponds to a %	centered neural receptive field) and therefore we are comparing central % 	ordinates of a centered nRF and a decentered PSF. It would be tedious% 	to correct this problem here because I would have to figure out the% 	phase shifts needed to align the two spatial fns. Better to do the% 	allignment in the spatial domain, which is implemented in metric Y(11)% 	of PSFMetrics.% R(9) (Strehl ratio computed by MTF method) and R(10) (visual Strehl ratio%   computed by MTF method) were conceived by LNT in Feb03 as an upper  %   limit to Strehl ratios computed from OTF and PSF. These new metrics are%   equivalent to computing SR for a hypothetical PSF computed assuming PTF%   = 0 (i.e symmetric & well centered).  Centering the PSF before%   computing SR in SF domain is good because it corresponds spatially to%   aligning the PSF with a diffraction PSF to compute their intensity%   ratios. However, the down side is that the PSF is also forced to be% 	symmetrical when PTF is set to 0. Therefore, this method should be less%	accurate than computing SR and VSR in spatial domain.%% LNT 17-Nov-02.  Based on Xin's program ZernikeLSF.m  Add novel metrics% R(6), R(7), and R(8).% LNT 22 Nov 02.  Normalize areas of visibility by diffraction-limited areas% LNT 27-Feb-03.  Fixed a problem uncovered by Li Chen.  DiffractionMTF.m% had some round-off errors that caused the support mesh grid to be %	255x255 instead of 256x256.  Fix was to supply vector of frequencies.% LNT 15Apr03. Add code to recompute Strehl (R(5)) and visual Strehl (R(7))%   using MTF instead of OTF.% LNT 24Aug03. Add input argument 'objectContrast' to allow user to scale%   the MTF and OTF appropriately for a reduced contrast object. The %   original conception of metrics R(1), R(2), R(3), R(4) were for object%   gratings of 100 percent contrast.  In this case, image contrast is%   given by the MTF which allows us to compute cutoff freq (for example)%   as the crossing of MTF and neural threshold.  However, for objects%   of contrast C, the retinal image contrast is MTF*C and therefore we%   should scale the MTF before passing it to AreaByNeuralLimitv3.m These 4%   metrics are the only ones sensitive to object contrast. The others %   are all normalized in such a way as to be contrast insensitive.% LNT 10Nov05. Add DLnorm to output list of variables. For this purpose,%   OTF area scales with pupil diameter and OTF volume scales with pupil %   area. This makes Strehl ratio 4x larger when pupil dia doubles, as%   expected. However, Visual Strehl doesn't grow as rapidly for diffraction%   limited optics because the neural weighting function doesn't scale with%   pupil size. Thus the benefit of large pupil isn't as great.% LNT 15-Oct-2010 Add CSF and sfCSF to output variables. They are computed%   by AreaByNeuralLimitv3 and passed through here without modification.%% © 2002, Xin Hong and Larry Thibos, 2003 Larry Thibos, Indiana University% set up default values for input argsif nargin < 8 || isempty(objectContrast), objectContrast=1; endif nargin < 7 || isempty(doit), doit = ones(10,1);  endif nargin < 6 || isempty(showit), showit=0; endNumberOfMetrics = 10;R(1:NumberOfMetrics) = NaN;			% initialize output vector% first do diffraction-limited system for supplied support mesh of frequencies% Note that the use of DiffractionMTF.m here instead of Zc2psf2otf.m is% much faster, but introduces small discrepancies (e.g. the area of% visibility is slighlty >1 for Zc=0)% Following line is a problem: %[f,MTF_1D, fx,fy,MTF_2D,fc] = DiffractionMTF(PupilDia,lambda,-min(Y(:)),Y(2)-Y(1));[f,MTF_1D, fx,fy,MTF_2D,fc] = DiffractionMTF(PupilDia,lambda,X(1,:),0);	                                        % use frequencies given by userfindex = find(f>=0);[cutDL,areaDL,csfDL,sfDL]=AreaByNeuralLimitv3(f(findex), ...    objectContrast*MTF_1D(findex),0, showit); % get cutoff & enveloped areapixsize = f(2)-f(1); 		% frequency resolution of the OTF (cyc/deg)pixArea=(pixsize.^2);DLv = sum(MTF_2D(:));		% volume under diffraction-limited MTF and OTFDLnorm=ones(1,NumberOfMetrics);%save the diffraction-limited normalizationsDLnorm(2)=areaDL*pixsize; % area under rMTF scales with pixel widthDLnorm(4)=areaDL*pixsize; % area under rOTF scales with pixel widthDLnorm(5)=DLv*pixArea; % volume under MTF scales with pixel area% see below for more DLnorm expressions%keyboardRI_MTF=[]; WI_MTF=[]; WI_OTF=[]; CSF=[]; sfCSF=[];if doit(1) | doit(2)	cflag = 1;				% analyze MTF, => use upper cutoff SF	[radius,meanW,RI,WI] = RadialAverage(abs(OTF),X,Y);		% compute rMTF	[R1,R2,CSF,sfCSF]= AreaByNeuralLimitv3(RI, objectContrast*WI, cflag, showit); 	                                        % compute 2 metrics for rMTF    if doit(1), R(1) = R1; end	if doit(2), R(2) = R2./areaDL; end	% normalize area by DL value    RI_MTF=RI; WI_MTF=WI; % save the results for Rowan        if showit       figure;        loglog(sfDL,csfDL,'k',sfCSF,CSF,'r');        xlabel('Spatial freq'); ylabel('Contrast sensitivity')       legend('DL','Exp') % Diffraction limited & experimental CSF predictions    endendif doit(3) | doit(4)	cflag = 0;				% analyze OTF, => use lower cutoff SF	[radius,meanW,RI,WI] = RadialAverage(real(OTF),X,Y);	% compute rOTF	[R3, R4] = AreaByNeuralLimitv3(RI, objectContrast*WI, cflag, showit); 	                                               % compute 2 metrics for rOTF    if doit(3), R(3) = R3; end	if doit(4), R(4) = R4./areaDL;	end% normalize area by DL value    RI_MTF=RI; WI_OTF=WI;end% find volume under 2-D surfacesOTFv = sum(real(OTF(:)));	% imag(OTF) sums to zero because of conjugate symmetryMTFv = sum(abs(OTF(:)));	% abs(OTF) = MTF% get OTF of diffraction-limited system for same support mesh of frequencies%[f,MTF_1D,fx,fy,MTF_2D,fc]=DiffractionMTF(PupilDia,lambda,-min(Y(:)),Y(2)-Y(1));if doit(5), R(5) = OTFv/DLv; end % normalize OTF volume by DL volume to get Strehl(OTF)if doit(6), R(6) = OTFv/MTFv; end % normalize OTF volume by MTF volume to get new metric% find volume under CS-weighted 2-D surfacesif doit(7) | doit(8) | doit(9) | doit(10)% 	[p1,Spoly1] = getNeuralCSF;	% first get Campbell&Green neural CSF% 	r=sqrt(X.^2+Y.^2);			% support matrix of radial frequencies% 	index=find(r <= 60);		% use only frequencies in the range	0-60c/d% 	logCS = polyval(p1,r(index));% 	CS = 10.^logCS;	% figure; surf(r(index),CS)	% xlabel('spatial frequency'); ylabel('neural contrast sensitivity')	% keyboard	%rNT = eval(Spoly1);			% radial neural threshold% revision of getNeuralCSF simplifies the code here:	r=sqrt(X.^2+Y.^2);			% support matrix of radial frequencies	index=find(r <= 64);		% use only frequencies in the range 0-60c/d	SF=r(index);				% the spatial frequencies for which we need                                     % neural contrast sensitivity 	[p1,Spoly1,sf,CS,Thresh]=getNeuralCSF(SF);	% get Campbell&Green neural                                                 % CSF at nominated SFs		% vol under product of surfaces is computed by inner product.     % Elemental base area is not needed since result is normalized	nOTFv = CS'*(real(OTF(index)));	% volume under neurally-weighted OTF                                     % (= complex-valued CSF)	nMTFv = CS'*(abs(OTF(index)));	% volume under neurally-weighted MTF=CSF	nDLv = CS'*MTF_2D(index);		% volume under neurally-weighted, DL-MTF	if doit(7), R(7)=nOTFv/nDLv; end % normalize neurally-weighted OTF vol      % by neurally-weighted diffraction-limited volume="visual Strehl:OTF"	if doit(8), R(8)=nOTFv/nMTFv; end % normalize by MTF volume to get our                                     %  new, phase-sensitive metric % recompute Strehl and visual Strehl using MTF instead of OTF	if doit(9), R(9)=MTFv/DLv; end     % normalize MTF volume by DL                                    % volume to get Strehl(MTF)	if doit(10), R(10)=nMTFv/nDLv;	end	% normalize MTFv2 by neurally-weighted                         %diffraction-limited volume = "visual Strehl:MTF"    DLnorm(7)=nDLv*pixArea; % VSOTF gets same treatment as DLnorm(5)=SROTF    DLnorm(9)=DLv*pixArea;  % SRMTF gets same treatment as DLnorm(5)=SROTF    DLnorm(10)=nDLv*pixArea; % VSMTF gets same treatment as DLnorm(5)=SROTFend% end of OTFMetrics.m