function [x,y,W,Mask,Mask90]=Zvec2Wxy(coeff,mode,step,wavefront,surface,asym)% Zvec2Wxy -Convert a vector of Zernike coefficients to wave aberration fn. W(x,y)%% Syntax: [x,y,W,Mask,Mask90]=Zvec2Wxy(coeff,mode,step,wavefront,surface,asym)%% Input args:	%	coeff = value of Zernike coefficients (vector)%	mode = corresponding mode numbers (vector)% 		if mode not supplied, assume they run from 1 to LENGTH(coeff)%	step = step size for sampling grid (default = 0.02 => 101x101 grid)%   wavefront = switch to return wavefront instead of wavefront error.%              This is done by skipping the subtracting off of central value.%				(default = 0 = false => return wavefront error).  %	surface = height ('h'), x-slope ('dx'), or y-slope ('dy'). default = 'h'%   asym = switch to make the returned matrices asymmetrical.  For example,%          if asym=1 and step=1/64 then W has size 128x128, middle = 65,65%          Default (0) is the original version, with odd size (eg 129x129)%% Output variables:%	x = mesh of x-pupil locations (normalized pupil coordinates)%	y = mesh of y-pupil locations (normalized pupil coordinates)%	W = wavefront aberration fn. reconstructed from Zernike coefficients%	Mask = pupil mask (1 inside pupil, 0 outside)%  Note: aberrations outside the unit circle are set to zero%	Mask90 = pupil mask capturing central 90% of pupil area (to avoid edge effects)%% Comment: RMS = std(W(find(Mask))) should equal norm(coeff);%% Method: %  Synthesize a 2 dimensional function by computing the weighted sum of %  Zernike basis functions.  Think of the result as an aberrated wavefront W*.%  By definition, W(0,0)=0 because the aberration function is the difference%  in optical path length for any point in the pupil compared to the chief ray%  passing through the pupil center.  Therefore, define W(x,y)=W*(x,y)-W*(0,0).%  The implied choice of sign convention in this definition is consistent with%  conventional optical practice.  For example, positive spherical aberration%  in an optical system causes the marginal rays to be phase advanced relative%  to the chief ray as they pass through the exit pupil. Therefore W(x,y) > 0 %  by our definiton, as required for positive aberration. %  Positive aberrations (by our sign convention) occur if the optical path%  length (OPL) of the marginal ray is shorter than the OPL of the chief ray.  %  Therefore, to get an aberration function with a positive sign we would%  compute W(x,y)=OPL(0,0)-OPL(x,y).  Note the reversal of order of subtraction%  compared to the previous formula written in terms of W*. This means that %  to interpret the output of this function as an OPD map we would need to %  change the sign, i.e. OPD(x,y) = -W(x,y)%% LNT 31-Mar-99.  3-Apr-99 Reference W to chief ray.  This makes piston irrelevant.% 23-Feb-00. Return Mask matrix to calling program.% 11-Mar-00. Note: the Zernike vector obeys the single-index convention of VSIA-2000,%  except that piston = 1, not 0. This is because Matlab starts indexing at 1, so to%  obey the VSIA convention is awkward.  For reporting purposes, should subtract 1 from%  all mode values or, preferrably, use the double-indexing scheme.%  Also, add switch to return absolute wavefront instead of wavefront error.  This has an%   effect only on Z(k,0) modes, e.g. piston Z(0,0), defocus Z(2,0), spherical ab. Z(4,0).% 22-Apr-00. Add option to show derivative surfaces.% 30Apr03. LNT  Add calculation of Mask90 for benefit of WaveMetrics.m% 12Jul03 LNT Allow inputs to be empty.% See also:  ZERNIKER% 09Jul06, LNT, add input arg asym% 15Jul07, LNT. speed up operation by using pre-computed Zernike basis functions. These are%   not yet available for wavefront slopes as sum of derivatives of Zernikes.% 09Apr08. Fix handling of slopes when wavefront==0% 25Sep08. LNT Fix handling of point near center when x?0.if nargin<6 | isempty(asym), asym = 0; endif nargin<5 | isempty(surface), surface = 'h'; endif nargin<4 | isempty(wavefront)	wavefront = 0;		% default is to return wavefront error, => W(0,0)=0endif nargin<3 | isempty(step)	step = 0.02;					% default step size for sampling gridendif nargin<2 | isempty(mode)	mode = [1:length(coeff)];		% default vector of coeffs (NOT sparse) endif ~isvector(coeff), error('Input to Zvec2Wxy must be a vector'), end% lay out a matrix of test locationsif asym    v = -1:step:(1-step); % the typical case in Fourier analysiselse    v = -1:step:1;      % the original symmetric caseend[x,y]=meshgrid(v);% synthesize a sampled waveform from Zernike functions.% msg='Building aberration function ...'modes = length(mode);				% number of modes to includeW = zeros(size(x));				% initialize the waveform matrix% reconstruct the wave aberration function using pre-computed basis functions.finished = false;if modes==6;    ZernBasis = zernikeR_6(x,y);	elseif modes==10;    ZernBasis = zernikeR_10(x,y);	elseif modes==15;    ZernBasis = zernikeR_15(x,y);	elseif modes==21;    ZernBasis = zernikeR_21(x,y);	elseif modes==28;    ZernBasis = zernikeR_28(x,y);	elseif modes==36;    ZernBasis = zernikeR_36(x,y);	elseif modes==45;    ZernBasis = zernikeR_45(x,y);	elseif modes==55;    ZernBasis = zernikeR_55(x,y);	elseif modes==66;    ZernBasis = zernikeR_66(x,y);else     disp('Number of modes is not standard')	    for i=1:modes			% evaluate & accumulate modes			 	 W = W + coeff(i)*zernikeR(x,y,mode(i),surface);		    end    finished = true;end;if ~finished   if surface ~= 'h'      disp('Efficient ZernikeBasis fns are not avail for derivatives of Zernikes')	      for i=1:modes			% evaluate & accumulate modes			         W = W + coeff(i)*zernikeR(x,y,mode(i),surface);		      end      finished = true;   else	  for j = 1:modes 							% Accumulate the wavefront     	W = W + ZernBasis(:,:,j) * coeff(j); 	      end      finished = true;   endendif ~wavefront && (surface(1) == 'h')	xc = find(x(1,:)==min(abs(x(1,:))));	% origin or closest point    if isempty(xc), xc = find(x(1,:)==-min(abs(x(1,:)))); end    yc = find(y(:,1)==min(abs(y(:,1))));	%    if isempty(yc), yc = find(y(:,1)==-min(abs(y(:,1)))); end	if isempty(xc) | isempty(yc)		error('No sample point found near center')	end	W = W - W(xc,yc);			% reference OPL to chief ray to get OPDend% set test locations outside unit circle to zero aberrationR2 = x.^2 + y.^2;% Mask = R2<=ones(size(x));  % original code% Mask90 = R2 <= 0.90*ones(size(x)); % a smaller mask to avoid edge effectsMask = (R2<=1);Mask90 = (R2<=0.9);	% a smaller mask to avoid edge effectsW = W.*Mask;    % clear the values outside the inscribed circle% end of function Zvec2Wxy