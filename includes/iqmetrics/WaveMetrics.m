function R=WaveMetrics(W,X,Y,mask,radius,lambda, doit,mask90,showit)% WaveMetrics - metrics of wavefront quality based on Marechal (rms), Rayleigh (absolute), and Klein (slope) criteria%% usage: R=WaveMetrics(W,X,Y,mask,radius,lambda,doit)%% input arguments:  %	W = 2D matrix of values of wavefront%	[X,Y] = support mesh for  W in physical units of mm%	mask = boolean mask defining area of pupil for which wavefront is defined%	radius = vector of pupil radius values (same units as X,Y) for interpolating rms error to get PFm%	lambda = wavelength of light in microns%	doit = boolean vector of switches indicating which metrics to compute.  default = ones(6,1)%	mask90 = mask that is concentric with 'mask', but has 90% of the area (95% of the diameter)%	showit = 1 to display wavefront & metric (diagnostic).  default = 0%% output vector of results:%	R(1) = RMSw = RMS of wavefront error computed over the whole pupil (microns)%	R(2) = PV = peak-to-valley difference (microns)%	R(3) = RMSs = RMS (i.e. std) of wavefront slope computed over the whole pupil (arcmin)%	R(4) = PFWc (nee PFWm) = pupil fraction satisfying Marechal-type criterion that RMS(wavefront) over central area < criterion%	R(5) = PFWt (nee PFWr) = pupil fraction satisfying Rayleigh-type criterion that absolute wavefront error from mean < criterion%	R(6) = PFSt (nee PFSk) = pupil fraction satisfying Rayleigh Klein-type criterion that magnitude of slope < criterion%	R(7) = PFSc (nee PFSm) = pupil fraction satisfying Marechal-type criterion that RMS(slope) < criterion% 	R(8) = Bave (nee meanBlur) = mean blur strength of wavefront (= mean length of power vectors across pupil, diopters)%  	R(9) = PFCt (nee PFCr) = pupil fraction satisfying Rayleigh-type criterion for wavefront curvature (blur strength)%  	R(10) = PFCc (nee PFCm) = pupil fraction satisfying Marechal-type criterion for wavefront curvature (blur strength)%% Note: lambda/4 = 0.1582 microns at 633nm, => M = -0.1218 Diopters, i.e. about 1/8 D = JND for most people.% Metrics R(4) and R(5) were conceived by Ray Applegate and Larry Thibos at ARVO-2002 (May, 2002)% Metric R(6) was implemented by Larry Thibos from a description by Stan Klein at Fall Vision Meeting, Oct 2002% Metric R(3) was devised by LNT in mid-November, 2002 as a metric analogous to R(1)% Metric R(7) was implemented 13Jul03 by LNT as the complementary metric to R(6)% Metrics R(8), R(9) and R(10) were conceived April 16,2003 on airplane to Houston as a way to quantify image Q in terms of %	wavefront curvature.  They were based initially on the Laplacian method for computing wavefront curvature (called R7, R8). %	This was unsatisfactory because it didn't handle astigmatism well.  The idea of computing a power-vector representation of%	curvature at each point on the surface developed by LNT in early July 03 and was implemented in Matlab on 12July03.%% LNT 3-Nov-02.  Based on PupilQ.m and including code from cRMS% LNT19-Nov-02.  Let user select the metrics to be computed% LNT 27-Apr-03.  Add metrics R(7) and R(8) which were conceived April 16,2003 on airplane to Houston% LNT 30-Apr-03. Fix problem with metric #3.  Replace WX(:) with WX(index90) to skip points outside pupil.%  Required modification of Zvec2Wxy.m to avoid edge effects at the pupil margin.% LNT 12Jul03.  Change metrics R(7) and R(8) to be based on blur strength = length of power vector. Add showit input arg.% LNT 13Jul03. Revise the formulation of R(6) to test Wx and Wy directly rather than their Pythagorean length because%	slopeMag could be constant over pupil yet have very poor image Q (e.g. slopeMag = 1 but in different directions). Rename R(7)%	as R(8) and R(8) as R(9).  Add new R(7) and R(10) as Marechal-type Pupil Fraction for slope (R7) and curvature (R10)% LNT 31Aug03. Add some more diagnostic displays for showit=1. Change acronyms for pupil fraction metrics.% LNT 28Sep03.  Changed method for calculating R(3) based on a suggestion from Xin.  Make acronyms consistent with JOV ms and AO manual.%  In reviewing the def of R(6) I'm not convinced that the change from slopeMag to current version was justified.  However, leave as is.% LNT Nov03 (approx). Reversed the logic for R(10) to handle frequent case of U-shaped curves.% LNT 19Sep06  Change convention for R(10). Null solution =0 instead of NaN% LNT 24Oct06  Fixed a longstanding bug on lines 132, 150 by adding double(**)% LNT 20May2010. Improved diagnostic graphics.% © 2002, 2003, 2006, 2010 Larry Thibos, Indiana Universityif nargin < 9 | isempty(showit), showit = 0;  endif nargin < 8 | isempty(mask90), mask90 = mask;  endif nargin < 7 | isempty(doit), doit = ones(8,1);  endif nargin < 6, lambda = 0.6328; end % default is HeNe laser wavelength	% initialize criterianumberMetrics = 10; Marechal = lambda/4; 		% criterion for rms wavefront errorRayleigh = lambda/4;		% criterion for absolute value of wavefront errorKlein = 0.291;				% criterion for slope values = 0.291 mrad = ±1 arcmin% Klein = Klein*2.5;  % simulate Ricco's area of diameter 5 arcmin  (LNT for Norberto, 09Sept2011)Curvature = 0.5; 			% criterion for curvature values.  for IAS eyes, 1/4 D generates many NaNs, 1D generates many 1.0s, 0.5 works OKR(1:numberMetrics) = NaN;				% initialize output vectorindex = find(mask);			% vectorized index of points inside the pupilindex90 = find(mask90);			% vectorized index of points inside a slightly smaller pupilnotindex90 = find(~mask90);		% vectorized index of points outside a slightly smaller pupilPupilRadius = min(max(X(index)),max(Y(index))); % choose minor radius as expedient solution for elliptical pupil% if max(X(index)) ~= max(Y(index)), error('Pupil is not curcular'), end;% % make sure wavefront is zero at pupil center (in case piston coeff was omitted)% [r,c]=size(W);	middlerow=floor(r/2)+1% cW=W(floor(r/2)+1,floor(c/2)+1);% if cW~=0% 	disp('Warning from WaveMetrics: central value of WAF is not zero.  This will be corrected now.')% 	W=W-cW;% end% compute wavefront slopesspacing = Y(2)-Y(1);	[WX,WY] = gradient(W,spacing);	% if pupil dimensions are in mm, and wavefront in microns, slope is milliradiansslopeMag = sqrt(WX.^2 + WY.^2);if showit    % display wavefront aberration function as a greyscale image    figure; subplot(1,2,1), imagesc(W.*mask);     axis xy;  axis equal; axis off; colormap('jet'); colorbar %is misleading	title ('Pupil Phase Map','FontSize',18);    % display profiles of wavefront aberration function	[Q,x_mid]=find(X(1,:)==min(abs(X(1,:))));	% col number of pupil center	[y_mid,Q]=find(Y(:,1)==min(abs(Y(:,1))));	% row number of pupil center	subplot(1,2,2); 	plot(X(1,:),W(y_mid,:),'g-',Y(:,1),W(:,x_mid),'r-');axis xy	xlabel('Pupil position','FontSize',14);	ylabel('Wavefront error (\mu m)','FontSize',14);	title ('Profiles of Phase Map','FontSize',18);	legend('Horiz.','Vert.');	%axis ([-1 1 lo hi]);end% metric #1:  RMSw = sqrt(wavefront variance).  units = microns% 	small RMS(wavefront error) => wavefront is flat => diffraction-limited image at infinityif doit(1), R(1) = std(W(index)); end% metric #2:  PV = peak-to-valley difference in wavefront error.  units = micronsif doit(2), R(2) = max(W(index)) - min(W(index)); end% metric #3:  RMSs = standard deviation of wavefront slope %	small RMS(slope) => wavefront is flat (but may be tilted) => displaced, diffraction-limited image at infinity% Resist the temptation to use slope magnitude = pythagorean sum of horizontal and vertical slopes%	because this wouldn't capture an aberration for which slope is constant in magnitude but changing in direction%	(i.e. a conic wavefront).  RMS of slope magnitude would therefore be zero, yet image Q is bad.  if doit(3)%	R(3) = ((std(WX(index90)) + std(WY(index90)))/2)/0.291;	% average the horizontal and vertical spread of slopes (arcmin)% The above definition of R(3) was used prior to 28Sep03 	R(3) = std([WX(index90); WY(index90)])/0.291;	% Xin Hong suggests std of concatenated horizontal and vertical slopes (arcmin)    % Jan 2011 LNT:  the result is half that obtained by the formula given    % in our JOV 2004 metrics paper: R(3)= sqrt(var(WX(index90))+var(WY(index90)))/0.291;end% metric #4: PFWc (nee PFWm) = pupil fraction for wavefront error, Marechal method (i.e. rms over concentric sub aperture)if doit(4)	[r,w]=XY2Radial(W,X,Y);	% convert wavefront error to polar coordinates, vectorize, & sort results radially	% -- loop through nominated pupil sizes in preparation for interpolation	for j=1:length(radius)		v = find(r<=radius(j));		% locate the relevant points in the pupil		s(j) = std(w(v));			% compute RMS for these points only	end	% interpolate results to find largest pupil satisying criterion that RMS < criterion	k= min( find(s >= Marechal) );	% index of the smallest pupil radius above criterion	if isempty(k), 		CritRadRMS = PupilRadius; 	else		CritRadRMS = interp1LNT(s(k-1:k),radius(k-1:k),Marechal); % 2-point interpolation	end		R(4) = (CritRadRMS/PupilRadius)^2; % pupil fraction is the square of ratio of radiiend% metric #5:  PFWt (nee PFWr) = pupil fraction for wavefront error, Rayleigh method (i.e. absolute wavefront error over full pupil)if doit(5) 	q = find(abs(W(index)-mean(W(index))) < Rayleigh);	% index to points with low wavefront aberrations    % note: this method fails for bifocals. Maybe we shouldn't subtract the mean?	R(5) = length(q)/length(index);	% fraction of points inside pupil that satisfy Rayleigh	if showit% 		% 20May2010. Fix longstanding error in the way good points are% 		visualized.  Has no effect on calculation of pupil fraction.%       Note that if the wavefront error is exactly 0, it will not be%       displayed as a "good point". This is unavoidable since points%       outside the pupil are also 0 and they need to be rejected.		figure; subplot(1,2,1); imagesc(W.*mask90); axis image; axis xy;  title('WF5: phase')		qq = find(abs(W.*mask90) > Rayleigh);	% index to points with high wavefront aberrations        goodPupil = W.*mask90; goodPupil(qq) = 0; % clear large wavefront points        goodPupil(find(goodPupil ~=0)) = 1;        subplot(1,2,2); imshow(goodPupil);	axis image; axis xy; 	title('Good pupil points')	    colormap 'jet'; colorbar('vert')    endend% metric #6: PFSt (nee PFSk) = pupil fraction for wavefront slope, Rayleigh-Klein method (i.e slope error over full pupil)if doit(6)%	q = find(abs(slopeMag(index)-mean(slopeMag(index))) < Klein);	% index to points with low transverse aberrations = OLD DEF PRIOR TO 13JULY03% Note: by subtracting off the mean from Wx & Wy, the metric is insensitive to prism modes. This is good since we don't want prismatic%	shifts in the image to affect our calculation of image quality.q = find( abs(WX(index90)-mean(WX(index90))) < Klein & abs(WY(index90)-mean(WY(index90))) < Klein ); % the points with x- and y-slopes near the mean	R(6) = length(q)/length(index90);	% fraction of points inside pupil that satisfy Klein	if showit		figure; subplot(1,3,1); imagesc(WX.*mask90); axis image; axis xy;  title('WF6: dW/dx')		subplot(1,3,2); imagesc(WY.*mask90); axis image; axis xy;  title('WF6: dW/dy')% 		qq = find( abs(WX-mean(WX(index90))) < Klein & abs(WY-mean(WY(index90))) < Klein ); % the points with x- and y-slopes near the mean% 		newMask = double(mask90); newMask(qq) = 2;	newMask = floor(newMask/2); 		qq = find( abs(WX-mean(WX(index90))) > Klein | abs(WY-mean(WY(index90))) > Klein ); % the points with x- or y-slopes greater than the mean        goodPupil = mask90; goodPupil(qq) = 0; % clear points with large wavefront slopes		subplot(1,3,3); imshow(goodPupil);	axis image; axis xy; 	title('Good pupil points')        colormap 'jet'; %colorbar('vert')	endend%metric #7: PFSc (nee PFSm) = pupil fraction for wavefront slope, Marechal method (i.e RMS of slope over concentric sub aperture)if doit(7)	[r,wx]=XY2Radial(WX(index90),X(index90),Y(index90));	% convert x-slope to polar coordinates, vectorize, & sort results radially	[r,wy]=XY2Radial(WY(index90),X(index90),Y(index90));	% convert y-slope to polar coordinates, vectorize, & sort results radially	% -- loop through nominated pupil sizes in preparation for interpolation	for j=1:length(radius)		v = find(r<=radius(j));		% locate the relevant points in the pupil		s(j) = ( std(wx(v))+std(wy(v)) )/2;			% average RMS(slope) for these points only	end	% interpolate results to find largest pupil satisying criterion that RMS < criterion	k= min( find(s >= Klein) );	% index of the smallest pupil radius above criterion	if isempty(k), 		CritRadRMS = PupilRadius; 	else		CritRadRMS = interp1LNT(s(k-1:k),radius(k-1:k),Klein); % 2-point interpolation	end		if showit		figure; plot(radius,s,'b-',CritRadRMS,Klein,'go');			xlabel('Pupil radius (mm)'); ylabel('average RMS(slope), mrad'); title('WF7: PF for slope, crit. pupil')		legend('data','Critical radius'), text(1,0.1,['Crit Radius = ',num2str(CritRadRMS)])	end	R(7) = (CritRadRMS/PupilRadius)^2; % pupil fraction is the square of ratio of radii	end	% metric #8:  Bave (nee meanBlur) = mean of blur strength, where blur strength = length of power vector. (diopters)%  principal curvature map = local dioptric power in terms of M,J. Blur = sqrt(M^2+J^2)% LNT 12Jul03if doit(8) |  doit(9) |  doit(10)	spacing = 1e-3*(Y(2)-Y(1));				% grid spacing in meters	[M,G,k1,k2,J,B]  = curvature(W*1e-6,spacing);	% convert W to meters so curvatures are in diopters	endif doit(8) 	R(8) = mean(B(index90));	% mean of blur strength values across the pupil (diopters)	if showit		fontsize=18; calib = [0;3]; % dioptric min & max to force a known calibration		figure, subplot(2,3,1);imagesc(M.*mask90), axis square, colormap 'jet', axis off, axis xy		title(['Mean Curvature, M'],'FontSize',fontsize);	colorbar('vert')				subplot(2,3,4); data=G.*mask90; data(1:2)=calib;		imagesc(data), axis square, colormap 'jet', axis off, axis xy		title(['Gauss Curvature, G'],'FontSize',fontsize);	colorbar('vert')				subplot(2,3,2); data=k1.*mask90; data(1:2)=calib;		imagesc(data), axis square, colormap 'jet', axis off, axis xy		title(['Princ. Curvature, k1'],'FontSize',fontsize);	colorbar('vert')				subplot(2,3,5); data=k2.*mask90; data(1:2)=calib;		imagesc(data), axis square, colormap 'jet', axis off, axis xy		title(['Princ. Curvature, k2'],'FontSize',fontsize);	colorbar('vert')				subplot(2,3,3);  data=J.*mask90; data(1:2)=calib;		imagesc(data), axis square, colormap 'jet', axis off, axis xy		title(['Astigmatism, J'],'FontSize',fontsize);	colorbar('vert')				subplot(2,3,6);  data=B.*mask90; data(1:2)=calib;		imagesc(data), axis square, colormap 'jet', axis off, axis xy		title(['Blur Strength, B'],'FontSize',fontsize);	colorbar('vert')	endend% metric #9:  PFCt (nee PFCr) = pupil fraction for wavefront curvature, Rayleigh tesselation methodif doit(9) 	q = find(B(index90) < Curvature);	% index to points with low blur values	R(9) = length(q)/length(index90);	% fraction of points inside pupil that satisfy curvature criterion	if showit		S = B.*mask90; 		notq = find(S >= Curvature);	% index to points with high blur values = "bad" points		S(notq)=-1;	% show high-blur points in black		figure; imagesc(S), axis square, colormap 'gray', axis off, axis xy, title('WF9: PFCt = pupil fraction, curvature, tess')	endend%metric #10: PFCc (nee PFCm) = pupil fraction for wavefront curvature, Marechal method (i.e blur strength over concentric sub aperture)if doit(10)	[r,w]=XY2Radial(B(index90),X(index90),Y(index90));	% convert x-slope to polar coordinates, vectorize, & sort results radially	% -- loop through nominated pupil sizes in preparation for interpolation	for j=1:length(radius)		v = find(r<=radius(j));		% locate the relevant points in the pupil		s(j) = mean(w(v));			% average blur strength for these points only	end	% interpolate results to find largest pupil satisying criterion that blur < criterion%	k= min( find(s >= Curvature) );	% index of the smallest pupil radius above criterion% 	if isempty(k), % 		CritRadRMS = PupilRadius; % 	elseif k==1	% the branch when k=min statement is used above% 		CritRadRMS = interp1LNT([0,s(k)],[0,radius(k)],Curvature); % 2-point interpolation (exchange X&Y)%	else%		CritRadRMS = interp1LNT(s(k-1:k),radius(k-1:k),Curvature); % 2-point interpolation (exchange X&Y)%	end	% reverse the logic for U-shaped functions where pupil is bad centrally but gets better as aperture expands	k= max( find(s <= Curvature) );	% index of the largest pupil radius less than criterion - works better for u-shaped functions	if isempty(k), 		CritRadRMS = 0;	% none of the points lie below criterion, so null solution (was NaN prior to 19Sep06)	elseif k==length(s)		CritRadRMS = PupilRadius; % solution is the whole pupil	else		CritRadRMS = interp1LNT(s(k:k+1),radius(k:k+1),Curvature); % 2-point interpolation (exchange X&Y)	end		if showit		figure; plot(radius,s,'b-',CritRadRMS,Curvature,'go');			xlabel('Pupil radius (mm)'); ylabel('average blur strength (D)');		title('Metric #10: PFCm = pupil fraction for wavefront curvature')		legend('data','Critical radius'), text(1,0.1,['Crit Radius = ',num2str(CritRadRMS)])	end	R(10) = (CritRadRMS/PupilRadius)^2; % pupil fraction is the square of ratio of radii	end	% end of WaveMetrics.m