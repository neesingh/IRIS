function [PSF,OTF,x,y,spaceHalfwidth,bandwidth,opticalMask,Wxy,PF,xp,yp,...    pupilMask,samplingPeriod,fundamentalFreq,mask90,GOpsf]= ...    Zc2psf2otf(lambda,a,PupilDia,N,PadFactor,MTFswitch,PTFswitch,alphaSCE,...    thresh,Toption,reflambda,PupilAspectRatio,fixChiefRay); % Zc2psf2otf: optical transfer function (OTF) and point-spread function% (PSF) %   from Zernike aberration coefficients or a wavefront aberration function.%% Syntax: [PSF,OTF,x,y,spaceHalfwidth,bandwidth,opticalMask,Wxy,PF,xp,yp,...%     pupilMask,samplingPeriod,fundamentalFreq,mask90]= Zc2psf2otf(lambda,...%     a,PupilDia,N,PadFactor,MTFswitch,PTFswitch,alphaSCE,thresh,Toption,...%     reflambda,PupilAspectRatio); %% Input arguments:%		lambda		= chosen wavelength for data analysis (m);%		a			= Zernike Coefficients for wave aberration %                       (microns, VSIA normalization);%              OR a square matrix of wavefront aberration values (microns)%               Mar08. In the case of elliptical pupils, Zernike coeffs or%               the wavefront input is interpreted as existing over a%               circlular pupil. This optical system is then viewed through%               an elliptical pupil with aspect ratio = PupilAspectRatio%               For the pupil function Axy*exp(iWxy), Axy is the pupil mask%		PupilDia	= diameter of pupil (m);%		N			= #bits used to represent Pupil Function %                      (e.g. N=7 for 128x128; N=8 for 256x256). default = 7%					  note: increasing N increases the frequency resolution%                       of OTF and increases spatial width of PSF (degrees)%                     note: N is ignored if "a" is a square matrix. %                       In that case, program uses N=size(a).%		PadFactor	= multiplying factor for size of PSF, OTF relative to%                       PF (integer, but not necessarily power of 2).  %                       default =2 = minimum value needed to see the entire%                       OTF up to cutoff frequency. PadFactor effectively%                       increases pupil diameter by surrounding the given%                       pupil with zero values of amplitude.%					  note: increasing PadFactor increases the bandwidth of%                        OTF and increases spatial resolution of PSF but has%                        no effect on angular size of PSF in degrees.%                       PadFactor =1 is not recommended because it produces %						aliasing in OTF due to undersampling.%		MTFswitch	= 0 to return computed OTF, %					= 1 to set MTF portion of OTF=diffraction-limited value%					  default = 0%		PTFswitch	= 0 to return computed PTF %					= 1 to set PTF part of OTF=0=diffraction-limited value%					  default = 0%		alphaSCE = Stiles-Crawford pupil apodization factor in the equation: %				Relative Intensity Sensitivity = exp(-alpha*r^2), where %               r = pupil location in mm. Use alphaSCE=0 for a uniformly  %				weighted pupil. Default = typical human value = 0.115 mm^-2%				See "Notes on scaling of pupil apodization function.pdf" %               (14Mar04) for proof that amplitude apodization is the %				Gaussian equation: A=exp(-gamma*r^2), where %               gamma = 0.5*alphaSCE*pupilRad^2%       thresh = number of SDs above mean to use as threshold for clipping%               PSF before computing OTF. Suggest 2 for experimental PSFs.%               default= NaN to not clip (i.e. use the whole PSF)%       Toption = switch to select the type of thresholding to be performed%       reflambda = wavelength (m) used to scale pupil sampling & padding.%               default=lambda to achieve prior functionality (i.e full %                   resolution of pupil function for the test wavelength. %               Since the number of sample points across the pupil function%               = 128*reflambda/lambda, a good choice for reflambda is%               0.4e-6 to get the full resolution (128 sample points)%               for a given test wavelength lambda. %       PupilAspectRatio = b/a = vertical/horizontal axes of elliptical %               pupil (axes are horiz & vert). default = 1 (circular pupil)%               Obliquely oriented pupil axes are not allowed yet.%       fixChiefRay = switch to force chief ray to be the z-axis.%               default=true%					% Output variables:%		PSF			= Point Spread Function, centered to correspond with %                       support grid. PSFs are scaled so they sum to one%						 = central ordinate of OTF%		OTF			= Optical Transfer Function, centered to correspond %                      with support grid, for complex exponential basis fns%		x,y			= normalized meshgrid supporting PSF,OTF,GOpsf; range=-1 to 1%		spaceHalfwidth 	= half-width of PSF in arcmin%		bandwidth 	= highest spatial freq (cyc/deg) in OTF = Nyquist freq.%		opticalMask = 1 for spatial freq less than optical cutoff, else=0%		Wxy			= wavefront aberration function (microns). If input "a"%                     is a wavefront, and reflambda~=lambda, then Wxy is a %                     resampled version of "a" on a commensurate grid.%		PF			= pupil function without padding%		xp,yp		= normalized meshgrid supporting Wxy, PF; range=-1 to 1%		pupilMask 	= circular mask for xp, yp.  This is amplitude %                       apodization filter if alphaSCE~=0%		samplingPeriod = spatial resolution (i.e. pixel size) of PSF in deg%		fundamentalFreq = frequency resolution of OTF in cyc/deg%		mask90 		= pupil mask that is only 90% of radius^2 = 95% of %                       radius, to avoid edge effects in WaveMetrics.m%       GOpsf       = geometrical optics approximation to PSF, with support x,y%% Note on units:  multiply x,y by spaceHalfwidth to put support for PSF  %           into physical units (arcmin).% 		 multiply x,y by bandwidth to put support for OTF into physical %           units (cyc/deg).% 		 multiply xp,yp by PupilDia/2 to put support for Wxy, PF into %           physical units (m).%% Note on signs: % positive h. tilt pushes PSF to left, pos. h. coma makes a PSF with head% to right, tails to left% positive v. tilt pushes PSF down, pos. v. coma makes a PSF with head up, %   tails down like a rocketship%% Note on prism:%  vert. slope of wavefront in normalized pupil coordinates = 2*a(2)=2*RMS%  Offset of PSF (milliradians) from origin = -2*a(2)/pupilradius(mm)%% 7Jul06 comment:% Effect of wavelength-dependent pupil resolution on size of returned vars:%  If lambda ~= reflambda, then Wxy,PF,xp,yp,pupilMask are all reduced in %   size by factor lambda/reflambda. They could easily  be padded out to %   next power of 2 using padmatrix if required.  %  Numerical values of scalars spaceHalfwidth,bandwidth, are unaffected%    even though the DL cutoff changes with wavelength.%   Tested with test_Zc2psfV2.m%% Based on MTFfromFFT_IAS.m by Xin Hong, Optometry School, Indiana Univ.% as modified by LNT 14May01.  Re-organized & documented by LNT 18Jun01.% 6-Oct-01. LNT. Add opticalMask to output variables.  Fix an error in %   handling of MTFswitch=1 case.% 30-Oct-02 LNT. Add wavefront (Wxy), pupil function (PF), samplingPeriod &%   fundamentalFreq to list of returned variables. % 27Jun03LNT  Add calculation of Mask90 for benefit of WaveMetrics.m  This%   duplicates functionality in Zvec2Wxy, which is poor programming %	practice! but needed nonetheless.% 9Nov03. LNT. corrected a small flub on line 90% 14Mar04.  Add alphaSCE as an input parameter.  Return the apodization%   filter in output variable pupilMask. % 30Jan05. Implement thresholding of PSF previously done in PSFmetrics.m%   The aim is to suppress wide tails in PSFs of highly aberrated eyes.%   By doing the thresholding here, the OTF reflects the thresholding.% 27Mar05. LNT. At the request of Arthur and Pete, allow input parameter%   "a" to be a matrix defining the wavefront aberration function,%    rather than a vector of Zernike coeffs.%   Tested with script test_Zc2psfV2% 05Apr06. LNT. Let resolution of pupil mesh vary with wavelength so that%   sample mesh for PSF and OTF are independent of wavelength. This avoids%   having to interpolate results onto a common grid in polychomatic case.%   Add reflambda (wavelength for scaling pupil sampling & padding) to input.%   This change is backwardly compatible by default: reflambda=lambda% 07Jul06. Implement the variable sampling density method for wavefront%   inputs.% 19Sep06.  Add capability to compute geometrical optics approximation to%   the PSF using spot diagrams.  Verified this works with Zernike inputs %   and wavefront inputs using test_Zc2psfV2.m and a defocused eye. Also%   verified that changing test wavelengths from 0.6 to 0.4, leaving%   reflambda fixed at 0.4, gave commensurate GOpsfs (i.e. sample points%   are at the same locations) and form of spot diagram was unaffected.%   This is one advantage of the GOpsf: it is independent of wavelength at%   this stage. When ConvertWavelength is installed to adjust the wavefront%   for wavelength, then a small effect is expected on GOpsf.%   Next step is to make the GOpsf an optional substitute for the standard%   wave-optics PSF, and to compute OTF from it. This should give an%   acceptable result for large aberrations, and may extend the useful %   dynamic range of the metrics.% 26Mar08. Add capability to compute pupil fn for elliptical pupil. Assume%   for now that the pupil is aligned with x & y-axes. Code hasn't been  %   tested for wavefront inputs.% 04Jan09. Add a call to pointWavefront.m to force chief ray to be z-axis.%   Need to find a convenient way to report the amount of rotation invoked.% 06Apr09. Make pointWavefront.m an option controlled by fixChiefRay% 25Jul09. Add GOpsf to output. Verify that it matches Fourier PSF for test%   cases of vertical and horizontal coma.% © 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009% Larry Thibos, Indiana University%% set up default variables%fixChiefRay=1;if nargin < 13 | isempty(fixChiefRay)	fixChiefRay=1; % default = fix the chief ray by rotating the wavefrontend                   if nargin < 12 | isempty(PupilAspectRatio)	PupilAspectRatio=1; % default pupil is circular end                   if nargin < 11 | isempty(reflambda)	reflambda=lambda; %default wavelength for scaling the sampling mesh end                   % that supports the pupil function if nargin < 10 | isempty(Toption)	Toption = 0;	%  default is to skip thresholdingendif nargin < 9 | isempty(thresh)	thresh = NaN;	% default is to use the whole psf (the method used end                    % prior to 30Jan05)if nargin < 8 | isempty(alphaSCE)	alphaSCE = 0.115;	%  default = typical human value = 0.115end                        % set alphaSCE = 0 for a uniform pupil. if nargin < 7 | isempty(PTFswitch)	PTFswitch = 0;	%  default is to return the computed PSFendif nargin < 6 | isempty(MTFswitch)	MTFswitch = 0;	%  default is to return the computed OTFendif nargin < 5 | isempty(PadFactor)	PadFactor = 2;	% default arrays for PSF and OTF are 2^(N+1) x 2^(N+1) endif nargin < 4 | isempty(N)	N = 7;			% default is for pupil function to be 128 x 128 arraysend% initializationdiagnostic = 0;k=2*pi/lambda;arrayHalfSize = 2^(N-1);  % reduce N by 1 because array is double-sidednewHalfSize = PadFactor*arrayHalfSize;	%size of pupil after padding with 0lambdaRatio=lambda/reflambda; %resolution of pupil mesh varies w/lambdanewPadFactor = PadFactor*lambdaRatio; % accounts for wavelength changes                                              		% generate pupil mask v=[-arrayHalfSize:lambdaRatio:(arrayHalfSize -1)]/arrayHalfSize; %asymm.[x,y]=meshgrid(v);									if PupilAspectRatio > 1    mask=((x*PupilAspectRatio).^2 + y.^2) <= 1; % a vertical ellipse    mask90=((x*PupilAspectRatio).^2 + y.^2) <= 0.9; % a smaller maskelseif PupilAspectRatio < 1    mask=(x.^2 + (y/PupilAspectRatio).^2) <= 1; % a horizontal ellipse    mask90=(x.^2 + (y/PupilAspectRatio).^2) <= 0.9; % a smaller maskelse     mask=(x.^2 + y.^2) <= 1;     % a circular pupil    mask90=(x.^2 + y.^2) <= 0.9;   % a smaller mask for 90% of the pupil area                                 %    but avoiding edge effects    mask50=(x.^2 + y.^2) <= 0.09;  % halve-diameter maskendxp=x; yp=y;	pupilMask=mask;				% save support mesh for pupil% figure; imagesc(pupilMask); axis equal;  % diagnostic% test if input parameter "a" is a Zernike vector or a wavefrontif isvector(a)  % reconstruct a wavefront from the zernike coeffs    % reconstruct the wave aberration function from Zernike coefficients    % using pre-computed basis functions.     modes=length(a);    if modes==6;        ZernBasis = zernikeR_6(x,y);	    elseif modes==10;        ZernBasis = zernikeR_10(x,y);	    elseif modes==15;        ZernBasis = zernikeR_15(x,y);	    elseif modes==21;        ZernBasis = zernikeR_21(x,y);	    elseif modes==28;        ZernBasis = zernikeR_28(x,y);	    elseif modes==36;        ZernBasis = zernikeR_36(x,y);	    elseif modes==45;        ZernBasis = zernikeR_45(x,y);	    elseif modes==55;        ZernBasis = zernikeR_55(x,y);	    elseif modes==66;        ZernBasis = zernikeR_66(x,y);    else error('Number of modes is not standard')	    end;    Wxy=zeros(size(x)); % initialize the wavefront    for j = 1:modes   % accumulate Wxy by summing basis functions        Wxy= Wxy + ZernBasis(:,:,j) * a(j); %  scaled by coeffs    end    clear ZernBasis;else    [N,N1]=size(a); % ignore user's request for N if input is square matrix    if N~=N1, error('Input matrix "a" must be square'), end%    if lambdaRatio == 1  % 24-Oct-06 This is not general enough test    if size(a) == size(mask)        Wxy=a;  % the method prior to 6Jul06, works also if lambdaRatio==1    else        % adjust resolution of pupil mesh same as for Zernike inputs        Wxy=imresize(a,size(mask)); %resample the input wavefront    endendif fixChiefRay[Wxy,ZcPrism] = pointWavefront(Wxy,xp,yp);%make chief ray = z-axis(04Jan09)disp(['Chief ray prism [C1,-1 = ',num2str(ZcPrism(2)), ' ;  C1,+1 = '...     ,num2str(ZcPrism(3)), ' ] corrected.'])    % tell the user what happenedend% compute physical scaling factorscutoffFreq = (PupilDia/lambda)*(pi/180);		% optical cutoff frequency                                                 % in cyc/deg for this pupil bandwidth = cutoffFreq*newPadFactor/2;	% highest spatial frequency represented                                    % in 2-sided OTF = Nyquist freq.samplingFreq = 2*bandwidth;			 % sampling frequency = 2* Nyquist freqsamplingPeriod = 1/(samplingFreq);	 % period (deg) between spatial samples                                     % = 1/ sampling freqspaceHalfwidth = 60*samplingPeriod*newHalfSize;	%half-width of PSF (arcmin)% spaceHalfwidth = 60*arrayHalfSize/(cutoffFreq*lambdaRatio); % same value% spaceHalfwidthRadians = arrayHalfSize*lambda/PupilDia; % more fundamentalfundamentalFreq = bandwidth/newHalfSize;% fundamental freq=freq. resolution% create the pupil function;PF = exp(sqrt(-1)*k*Wxy*1e-6).*mask; % temporary removal for EMVPO figure%PF = exp(sqrt(-1)*k*Wxy*1e-6).*mask.*mask50; % temporary kludge for EMVPO% figure; imagesc(angle(PF))    % diagnostic. PF is centered in arrayif alphaSCE ~= 0, 	gamma =0.5*alphaSCE*(PupilDia*0.5e3).^2;%Gaussian amplitude apodization 	mask = mask.*exp(-gamma*(x.^2+y.^2));   	% pupil apodization array	PF = PF.*mask;    % amplitude appodization =sqrt(intensity apodization)end% xp=x; yp=y;	pupilMask=mask;				% save support mesh for pupil% generate support meshgrids for PSF and OTFvv = [-newHalfSize:1:(newHalfSize -1)]/newHalfSize;	% asymmetric meshgrid,                                                     % includes origin[x,y] = meshgrid(vv);radius = sqrt(x.*x+y.*y);		% a mesh of radial distances on unit squaremask = radius<=1;radius = radius.*mask;					% clear points outside unit circleif true  % prepare for graphics that compare wavefront and GO PSFs% makeSpotDiagram % this is G.O. spot diagram approximation to the PSFidx=find((xp.^2+yp.^2)<=0.99); % indices into pupil (avoid edge effects)xstep = 0.5e3*PupilDia*(xp(1,2)-x(1,1));% x-distance between samples,mmystep = 0.5e3*PupilDia*(yp(2,1)-y(1,1));% y-distance between samples% Gradient gives transverse aberration, in microns/mm = milliradians% sign convention: T>0 => wavefront points towards z-axis [Tx,Ty] = gradient(Wxy,xstep,ystep);  % gradient in mRadTx = Tx(idx); Ty = Ty(idx);           % trim to valid pupil locationsspots = 3.4377*[Tx,Ty];               % coordinates of each spot,arcminss = 1;                               % a subsample integerxbins = x(1,[1:ss:end]);              % bins in normalized coordinatesxbins = xbins + (xbins(2)-xbins(1))/2; % convert to bin centersxbins = spaceHalfwidth*xbins;          % convert to physical unitsybins = y([1:ss:end],1);ybins = ybins + (ybins(2)-ybins(1))/2; % convert to bin centersybins = spaceHalfwidth*ybins;          % convert to physical units%GOpsf = hist3_LNT(spots, {xbins ybins});   % bin the spotsGOpsf = hist3(spots, {xbins ybins});   % bin the spotsGOpsf = GOpsf'./sum(GOpsf(:));       % transpose & normalize to unit volumeGOpsf = fliplr(flipud(GOpsf));       % rotate 180deg to match PSF% see hist3_LNT for notes on why the histogram needs transposing end%PFshift = ifftshift(PF); % strange: this has no effect on PSF!% May have to do with the way FFT2 pads. This is not documented in HELP.% figure; imagesc(angle(PFshift))% corners of PF are in center of array% Let FFT2 pad the PF for us.  Does FFTn shifts the argument first, %  before padding?  Why doesn't it matter if PF is shifted first??%*move forward* newHalfSize = PadFactor*arrayHalfSize;	%size of pupil after padding with 0ASF = ifft2(PF,2*newHalfSize,2*newHalfSize); 	% amplitude spread function PSF = ASF.*conj(ASF);			% intensity spread function, not centeredPSFvol = sum(sum(PSF));		% pseudo-volume under PSF (don't multiply by %                               elemental area of base)% disp(['PSF volume= ', num2str(PSFvol)]);  % diagnostic: volume under PSFPSF = PSF/PSFvol; % force all PSFs to sum to one = central ordinate of OTF%figure; imagesc(fftshift(PSF)); axis square; colorbar; %diagnostic display%puzzling why PSF has to be shifted, even if PFshift is used to compute PSF% threshold the PSF before computing OTF - EXPAND THIS TO HANDLE TOPTIONif Toption~=0    threshold = mean(PSF(:))+thresh*std(PSF(:));    tmask = (PSF>threshold);  %mask region above threshold. Not contiguous.    disp('Zc2psf2otf: Thresholding the PSF')    PSF = PSF.*tmask;           % replace PSF with its masked version    PSF = PSF/sum(PSF(:));      % renormalize to unit volumeend%%%%%%%%%%% Strategic issue:   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Should we shift the PSF onto it's own center before computing OTF?% Test case is the diffraction-limited system with prism. We let the% calling program decide. For example, QualityMetrics omits prism from the% Zernike vector before handing it off to Zc2psf2otf. This should make the% PSF nominally centered, so OTF should not have large linear phase shifts.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fourier transform PSF to get Optical Transfer Function (OTF). Because PSF% is real-valued, OTFs have conjugate symmetry (i.e. the real part has even % symmetry and the imaginary part has odd symmetry)OTF=fft2(PSF);			   % optical transfer function, origin not centered% disp(['maxotf= ', num2str(max(max(abs(OTF))))]);	% diagnostic: should be                                            % unity since volume of PSF = 1 % * move the following block of code forward (19sep06) *% % generate support meshgrids and scale factors% vv = [-newHalfSize:1:(newHalfSize -1)]/newHalfSize;	% asymmetric meshgrid, %                                                     % includes origin% [x,y] = meshgrid(vv);% radius = sqrt(x.*x+y.*y);		% a mesh of radial distances on unit square% mask = radius<=1;% radius = radius.*mask;					% clear points outside unit circle% cutoffFreq = (PupilDia/lambda)*(pi/180);		% optical cutoff frequency %                                                 % in cyc/deg for this pupil % bandwidth = cutoffFreq*newPadFactor/2;	% highest spatial frequency represented%                                     % in OTF = Nyquist freq.% samplingFreq = 2*bandwidth;			 % sampling frequency = 2* Nyquist freq% samplingPeriod = 1/(samplingFreq);	 % period (deg) between spatial samples%                                      % = 1/ sampling freq% spaceHalfwidth = 60*samplingPeriod*newHalfSize;	%half-width of PSF (arcmin)% fundamentalFreq = bandwidth/newHalfSize;% fundamental freq=freq. resolution% pix=spaceHalfwidth*[(x(1,2)-x(1,1)),(y(2)-y(1))] % diagnostic% fundamentalF = bandwidth*[(x(1,2)-x(1,1)),(y(2)-y(1))] % double check% makeSpotDiagram% apply optical constraint that OTF=0 beyond the cutoff freq.% in practice this isn't very important because the values being masked off% are so small.  in theory, the mask should be elliptical when the pupil is% elliptical, but i haven't implemented this yet.opticalMask = radius<=(cutoffFreq/bandwidth);	% =1 for all freq < cutoffopticalMask = opticalMask.*mask; 	  % tidy up points outside unit circle% center the origins of PSF & OTF for display purposesPSF = fftshift(PSF);OTF = fftshift(OTF).*opticalMask;% here is how to shift origin of PSF & OTF back to beginnin of matrix %  for computaitonal purposes% PSFdisplay = ifftshift(PSF);% OTFdisplay = ifftshift(OTF);if diagnostic  % diagnostic graphics compares wavefront and GO PSFs    figure; subplot(1,2,1)    imagesc(GOpsf), colormap('gray'), axis square; axis xy    title('GO PSF')    subplot(1,2,2)    imagesc(PSF), colormap('gray'), axis square; axis xy    title('Wave PSF')    % compare horizontal profiles    figure; plot(spaceHalfwidth*x(1,[1:ss:end]), GOpsf(129,:), 'b-o', ...        spaceHalfwidth*x(1,:),PSF(129,:), 'r-o')    set(gca,'XLim',[-10 10])     legend('Spot diagram', 'Wave-optics PSF')    title('PSF profiles (diagnostic from Zc2psf2otf)')end% convert OTF to polar form and apply switch options (see DiffractionMTF.m)MTF=abs(OTF);if MTFswitch==1	fr = radius*bandwidth/cutoffFreq;		% scale frequencies so cutoff                                             % falls on edge of unit circle	MTF = (2/pi)*( acos(fr) - fr.*sqrt(1-fr.^2) );	% Goodman's formula for                                                % diffraction-limited MTF	MTF = opticalMask.*MTF;			% clear MTF for frequencies > cutoffendPTF=angle(OTF);if PTFswitch==1	PTF = zeros(size(PTF));		% phase = 0 for diffraction-limited systemendif (MTFswitch+PTFswitch) >0		OTF = MTF.*(cos(PTF) + i*sin(PTF));	     % recombine complex spectrum	PSF = fftshift(ifft2(ifftshift(OTF))); % recompute PSF of altered OTFendPSF = real(PSF); % omit nuisance imaginary part due to rounding errors