function [z,F] = Quality2Zc(Q,M,OSAmodeNum,calibFile)% Quality2Zc - find coefficient of a specified Zernike mode that produces quality Q for metric M% Note: -z is also a solution.  This function is the inverse of QualityMetrics.m%% Usage: [z,F] = Quality2Zc(Q,M,OSAmodeNum,calibFile)%% Input: %	Q = scalar value of a quality metric (may be vector eventually)%	M = [1 x 2] vector defining metric number. %		M(1)=1 for WF, M(1)=2 for PS, M(1)=3 for SF.%		M(2)= metric number within group defined by M(1).  e.g M=[2,4] specifies PS(4) = half width at half height%	OSAmode = mode number of solution%	calibFile = calibration *.mat file produced by QualityvsZc.m,  containing:%		R = [r x c x s] calibration matrix.  each row is a Zc, each col is a metric, each slice is an OSAmode%		v = [1 x r] vector of aberration coeffs corresponding to the rows of R%		txt = [c x 1] cell array describing the metrics represented in R%		PupilDia = pupil diameter%		lambda = wavelength%		Example is file QvsZc6mm.mat%% Output: %	z = positive value of zernike coefficient. -z is also a solution%	F = fractional error of interpolated value%% Method:  exchange the x & y axes of the calibration curve to enable interpolation of the metric value (x)%	needed to yield the desired Z coeff.  Check is to use this Z-coeff to re-compute the metric.%% LNT 27Nov02.  Needed to analyze Dave William's data on mode-matching.load(calibFile);	% contains QvsZ6mm PS PupilDia R lambda txt v (see QualityvsZc.m)%PupilDia,lambda	% diagnosticz=NaN; F=NaN;		% initialize output variables to the "no solution found" condition% convert M to a sequential metric numberif M(1)==1	metricNum=M(2);elseif M(1)==2	metricNum=6+M(2);elseif  M(1)==3	metricNum=16+M(2);end[rows,cols,slices] = size(R);		% [41 z-values x 24 metrics x 20 OSA modes] for QvsZc6mm.matx = v; y = R(:,metricNum,OSAmodeNum);	% the calibration curve to invert[a,idx] = ismonotonic(y); % monotonic=aif a==1	z = interp1(y,x,Q);				% find the zernike coeff that would yield Qelse	z=NaN;	for j=1:(length(idx)-1)		xx = x(idx(j):idx(j+1))';	% process 1 segment at a time		yy = y(idx(j):idx(j+1));%		[xx,yy] 					% diagnostic display		z = interp1(yy,xx,Q);		% find the zernike coeff that would yield Q		if ~isnan(z), break, end	% stop when first valid interpolation is found	endend% check resultif ~isnan(z)	Zc = zeros(1,(slices+1)); Zc(OSAmodeNum+1) = z;		% set up a vector of Zernike coeffs	modes = [1:(slices+1)];								% vector of mode numbers	metricType = zeros(3,1); metricType(M(1))=1;	doit = zeros(10,3); doit(M(2),M(1)) = 1; 			% set up a matrix of boolean switches		[WF,PS,SF]=QualityMetrics(Zc,PupilDia,lambda,modes,metricType,doit); % calculate the metric from interpolated value of z coeff.	RR = [WF,PS,SF];									% concatenate results	newQ = RR(metricNum);	F=(newQ - Q)./Q; 										% fractional error		plot(x,y,'b-',z,Q,'go',z,newQ,'rx')% 	ylabel('Metric of Optical Quality'), xlabel('Value of Z coeff')% 	legend('Calib curve','interpolated result','verification result')else	disp('Quality2Zc.m failed to return a solution')	M, Q	plot(x,y,'b-')										% plot calib curve anyway to see what we missedend