function [WF,PS,SF,DLnorm]=QualityMetrics(Zc,PupilDia,lambda,modes,...  metricType,doit,showit,saveit,thresh,inputType,nbits,padfactor,...  PupilAspectRatio,fixChiefRay)% QualityMetrics - compute metrics of optical quality from Zernike coeffs, %  or a wavefront matrix, or (in the future) Seidel coefficients%% Syntax:% [WF,PS,SF,DLnorm]=QualityMetrics(Zc,PupilDia,lambda,modes,...% metricType,doit,showit,saveit,thresh,inputType,nbits,padfactor,...% PupilAspectRatio,fixChiefRay) %% Demo: type [WF,PS,SF,DLnorm]=QualityMetrics;    % without input arguments%% Input args:%	Zc = row vector, or matrix of Zernike coeffs (microns).  Each row is an%       observation (eye), each col is a Zernike mode. Zc(1) = piston. %     OR, if inputType='W', then Zc is a matrix of wavefront errors (microns)%           or a 3D stack of wavefront matrices.  Wavefronts are assumed to %           cover a circular pupil with diameter = width of square array. % 	PupilDia = diameter of pupil (m), scalar or vector with length=#rows in Zc%	lambda = wavelength of light (m)%	modes = vector of modes for computing metrics.  default=1:colsize of Zc%	     May be left empty when inputType = "W".%	metricType = 3x1 vector of boolean switches to select class of metrics %		metricType(1)==1 => computute wavefront-based metrics%		metricType(2)==1 => compute PSF-based metrics%		metricType(3)==1 => compute OTF-based metrics%	doit = 3 column matrix of boolean switchs to select individual metrics %		col 1 = vector "doit" described in WaveMetrics.m%		col 2 = vector "doit" described in PSFMetrics.m%		col 3 = vector "doit" described in OTFMetrics.m%	showit = 1 to display diagnostic figures.  default = 0 (don't show)%	saveit = 1 to save intermediate results in file QMresults.mat Default=0%   thresh = scale factor for mean to use as threshold for clipping PSF;%       default=0%   inputType = "Z" to interpret Zc as a vector or matrix of Zernike coeffs%             = "W" to interpret Zc as a matrix of wavefront values, or%                   a stack of such matrices%             = "S" to interpret Zc as a vector or matrix of Seidel coeffs%       default = "Z";  "S" option is not yet implemented%	nbits	= #bits used to represent Pupil Function.  Default =7 (128x128) %	PadFactor = multiplying factor for size of PSF, OTF relative to PF.%                (Integer, default = 2). %   PupilAspectRatio = b/a = vertical/horizontal axes of elliptical pupil.%       Scalar or vector of ARs with length = length(PupilDia).  default=1%   fixChiefRay = switch to force chief ray to be the z-axis. default=true%%	Note:  Enter Zc(n:m,:) as first argument to restrict computations to%       observations n to m. %% Output args:%	WF = row vector (or matrix of rows vectors) of metrics for wavefront domain%		WF(1) = RMSw = RMS of wavefront error over the whole pupil (microns)%		WF(2) = PV = peak-to-valley difference (microns)%		WF(3) = RMSs = RMS of wavefront slope over the whole pupil (arcmin)%		WF(4) = PFWc = pupil fraction satisfying Marechal-type criterion%               that RMS(wavefront) over central area < criterion %		WF(5) = PFWt = pupil fraction satisfying Rayleigh-type criterion%               that absolute wavefront error from mean < criterion %		WF(6) = PFSt = pupil fraction satisfying Klein-type criterion that%               magnitude of slope < criterion %       WF(7) = PFSc = pupil fraction satisfying Marechal-type criterion%               that RMS(slope) < criterion %       WF(8) = Bave = mean blur strength of wavefront (= mean length of%               power vectors across pupil, diopters) %       WF(9) = PFCt = pupil fraction satisfying Rayleigh-type criterion%               for wavefront curvature (blur strength) %       WF(10) = PFCc = pupil fraction satisfying Marechal-type criterion%               for wavefront curvature (blur strength) %	PS = row vector (or matrix of rows vectors) of metrics for PSF in spatial domain%    	PS(1) = diameter of a circular area centered on peak which captures%               50% of the light energy (arcmin)%    	PS(2) = equivalent width of maximum intensity (arcmin);%    	PS(3) = sqrt(second moment of light distribution about centroid (arcmin));%    	PS(4) = half width at half height (arcmin);%    	PS(5) = correlation width of light distribution (arcmin);%    	PS(6) = Strehl ratio (1 for diffraction-limited optics);%    	PS(7) = light-in-the-bucket (percentage of total energy);%    	PS(8) = standard deviation of light distribution;%	 	PS(9) = Dave William's entropy%	 	PS(10) = Dave William's G. neural blur%	 	PS(11) = Visual Strelh Ratio computed in space domain using%               Campbell & Green neural psf %	SF = row vector (or matrix of rows vectors) of metrics for spatial frequency domain%    	SF(1) = SFcutoff for rMTF%    	SF(2) = area of visibility for rMTF (normalized to diffraction-limited case)%    	SF(3) = SFcutoff for rOTF%    	SF(4) = area of visibility for rOTF (normalized to diffraction-limited case)%    	SF(5) = volume under OTF/ volume under diffraction-limited OTF = Strehl Ratio%    	SF(6) = volume under OTF/ volume under MTF %    	SF(7) = volume under CS-weighted OTF/ volume under CS-weighted OTF%               for diff-ltd optics = "visual Strehl" %    	SF(8) = volume under CS-weighted OTF/ volume under CS-weighted MTF %    	SF(9) = volume under MTF/ volume under diffraction-limited MTF =%               Strehl Ratio (MTF method) % 	 	SF(10) = visual Strehl ratio computed by MTF method.  This is VSR%               for a hypothetical PSF computed assuming PTF = 0. %  DLnorm = matrix of row vectors with diffraction-limited normalizations. %   To un-normalize the metrics, concatenate results into a single matrix%      like this:  ThruFocus = [WF,PS,SF];	       %   then .* each row in ThruFocus with a row vector from DLnorm.%   Un-normalizing may be useful when comparing pupils of different sizes.%   This is best done in the calling program to avoid having to re-compute%    metric values just to un-normalize them.%   Disadvantage of denormalization is interpreting units.  A compromise might %    be to normalize by the DL IQ for an optimum, fixed pupil diameter (e.g. 2.5mm). %   This raises an old issue: what is the optimum pupil size when C20 is corrected?   %     And does the result depend on accommodation?%%   Test program: testQualityMetrics.m%% LNT 23 Nov 2002.% LNT 27Nov02, add doit argument to enable calculation of specific metrics% LNT 01Sep03, let PupilDia be a vector when Zc is a matrix. Add "saveit"%   input parameter as a way of saving intermediate results without having %	to put them all in the output args% LNT 25Nov03- normalize PSF so volume = 1 before passing PSF to PSFmetrics%   (allows PSFmetrics to handle polychromatic PSFs) % LNT 19Feb04 - fix initialization of WF, PS, and SF % LNT 30Jan05 - add "thresh" as an input argument% LNT 10Nov05 - add DLnorm to list of output variables% LNT 14-Mar-06 - add a display of blurred eyechart to diagnostic graphics%  This requires files SmallEyeChart.mat and ShrinkImage.m% LNT 24-Oct-06.  Make wavefront compatible, which requires a new switch%   inputType.  A stub is left to allow vector of Seidel coefficients.%   Verified with case 4 in testQualityMetrics.m  Also added nbits and%   padfactor to input args to be passed along to Zc2psf2otf.m to give some%   flexibility when using diffractive lens wavefronts.% LNT 5-Mar-07 Add radial MTFs and OTFs to saved workspace% LNT 30Jul07.  Change the code to supply DL_PSF to PSFmetrics to%   improve accuracy in computing PSFmetrics 6,8,10,11. For series of test%   cases in testQualityMetrics, the difference is only 1% at most but for %   cases with prism the difference can be larger. Sowmya's discovery of an%   error in PSFcenter had no impact on this program.  However, it did%   reveal that wavefront metrics and SF metrics are also affected by%   prismatic terms in the Zernike vector of coefficients.  For that%   reason, it may be best to set Zc(1:3)=0 before computing wavefront%   metrics. Similarly, we may not want prism terms to influence SF metrics%   for monochromatic light, even though we need to keep chromatic%   variation of prism (i.e. TCA) when computing polychromatic PSF. What is%   the best way to factor out prism in the OTF?  Set Zc(2:3)=0?  or to%   subtract off linear phase computed from the displacement of PSFcenter?%   Omitting Zc(2:3)=0 is the easiest, so do it that way. This is the new%   default value for input arg modes. [Note: this approach was abandoned%   on 04Jan09]% LNT 5-Sep-07. Correct code to skip "mode" when inputType="W"% LNT 26Mar08. Add PupilAspectRatio to input args to take advantage of new%    feature in Zc2psf2otf.% LNT 14-Jul-09. Change the call to show_Zc2psf2otf so PSF dimensions are%    labeled.% LNT 07-Sep-2010. Add input variable "fixChiefRay" for passing on to%   Zc2psf2otf for diagnostic purposes.% LNT 09-Aug-2013. Corrected flub with DLnorm discovered by Hope Queener.%   It should be inside the loop that processes multiple Z-vectors.%  % © 2002, 2003 Larry Thibos, Indiana University[txt,numberMetrics]=metricNames;			% get current listing of metricsif nargin<14|| isempty(fixChiefRay), fixChiefRay=1; end                   if nargin<13|| isempty(PupilAspectRatio), PupilAspectRatio = 1; endif nargin<12|| isempty(padfactor), padfactor = 2; endif nargin<11|| isempty(nbits), nbits = 7; endif nargin<10|| isempty(inputType), inputType = 'Z'; endif nargin<9 || isempty(thresh), thresh = 0; endif nargin<8 || isempty(saveit), saveit = 0; endif nargin<7 || isempty(showit), showit = 0; endif nargin<6 || isempty(doit), doit = ones(max(numberMetrics),3); end		                        % default is to compute all metrics in a classif nargin<5 || isempty(metricType), metricType=[1,1,1]; end		                        % default is to compute all classes of metrics if nargin==0    % configure a demo   Zc=zeros(1,15); Zc(5)=0.315; % 0.97D *3mm dia = 10 arcmin blur circle   PupilDia =3e-3;   lambda =0.6e-6;    showit = 1;end[rowsize,colsize,slicesize] = size(Zc);if strcmp(inputType, 'Z'),     dataRange=[1:rowsize];			% the number of data sets supplied    if nargin<4 || isempty(modes), modes=[1:colsize]; end			    % prior to 30Jul07: default is to use all the modes    % after 30Jul07: default is to skip modes 1-3 (piston & prism)    % after 04Jan09 the prism issue is dealt with by pointWavefront.melseif strcmp(inputType, 'W')        dataRange=[1:slicesize];       % the number of data sets supplied     % user is responsible for making sure wavefronts have no prismelseif strcmp(inputType, 'S')         error('Seidel option is not yet available') % a stub for the future end  %  if length(PupilDia) ~= length(dataRange),	% legality check on PupilDia	if length(PupilDia)==1		PupilDia=ones(length(dataRange),1)*PupilDia;	% use same PupilDia for all inputs    else        error('Mismatch between number of Z-vectors and number of pupil diameters.')	endendif length(PupilAspectRatio) ~= length(PupilDia),	% legality check on PupilAspectRatio	if length(PupilAspectRatio)==1        PupilAspectRatio = ones(length(PupilDia),1)*PupilAspectRatio; 	else		error('Mismatch between number of PupilAspectRatios and number of pupil diameters.')	endendPupilRadius = 1e3*PupilDia/2;	% pupil radius in mmradius = [0:0.05:1]; % normalilzed radius values for interpolation in WaveMetrics% nbits=7;  nbits and padfactor were hard coded prior to 24Oct06% padfactor=2;	% has a big impact on execution speed% The following two lines were added 19Feb04, but didn't work when user%   asks for all the metrics % maxM=max(numberMetrics);% WF(dataRange,1:maxM)=NaN; PS(dataRange,1:maxM)=NaN; SF(dataRange,1:maxM)=NaN;		%WF(1:numberMetrics(1))=NaN; PS(1:numberMetrics(2))=NaN; SF(1:numberMetrics(3))=NaN;%Wstack=[];  PSFstack=[];  OTFstack=[];WFEmpty(1:numberMetrics(1)) = NaN;				% initialize output vectorPSEmpty(1:numberMetrics(2)) = NaN;				% initialize output vectorSFEmpty(1:numberMetrics(3)) = NaN;				% initialize output vectorj=0;	for rr=dataRange				% loop to process each Zernike vector in turn	j=j+1;			%  a separate loop counter in case r doesn't start at 1	a = zeros(1,colsize);			% initialize Zernike vector	disp(['DataSet # ',num2str(rr)])	% inform user of progress    % 24-Oct-06 branch according to the type of input provided by user    if strcmp(inputType, 'Z')                 a(modes) = Zc(rr,modes);			% omit modes user de-selected    elseif strcmp(inputType, 'W')           a = Zc(:,:,rr);              % wavefront = a slice of the input    elseif strcmp(inputType, 'S')         error('Seidel option is not yet available') % a stub for the future     end	PupilD = PupilDia(rr);			% pupil diameter (m) for this Z-vector	PupilR = PupilRadius(rr);    AspectRatio = PupilAspectRatio(rr);    % get the wavefront, PSF and OTF	[PSF,OTF,x,y,spaceHalfwidth,bandwidth,Mask,W,PF,xp,yp,pupilMask,...        samplingPeriod,fundamentalFreq,mask90] = Zc2psf2otf(lambda, a,...        PupilD,nbits,padfactor,[],[],[],thresh,[],[],AspectRatio,fixChiefRay);     % 30Jan05 - include threshold parameter to clip the PSF before the OTF    %  gets computed so OTF metrics will include effect of threshold.     %  make sure wavefront is zero at pupil center (in case piston coeff was omitted)    % get diffraction-limited PSF and OTF	[DL_PSF,DL_OTF] = Zc2psf2otf(lambda, 0*a,PupilD,nbits,...        padfactor,[],[],[],thresh,[],[],AspectRatio,fixChiefRay); 	% 30Jul07. Prior to today, neither DL_PSF nor DL_OTF was used in this	% program.  Change the code below to supply DL_PSF to PSFmetrics to	% improve accuracy in computing Strehl ratio.    	[r,c]=size(W);		cW=W(floor(r/2)+1,floor(c/2)+1);	if cW~=0%		disp('Warning from QualityMetrics: central value of WAF is not zero.  This will be corrected now.')		W=W-cW;	end	PSF = PSF/sum(sum(PSF)); % 25Nov03- normalize so PSF volume = 1 before                              % handing the PSF off to PSFmetrics 	maxPSF = max(PSF(:));	 % first do the wavefront metrics	if metricType(1)		if exist('doit','var')			WF(j,:) = WaveMetrics(W,xp*PupilR,yp*PupilR,pupilMask,...                radius*PupilR,lambda*1e6,doit(:,1),mask90,showit);		else			WF(j,:) = WaveMetrics(W,xp*PupilR,yp*PupilR,pupilMask,...                radius*PupilR,lambda*1e6,[],showit);        end    else        WF(j,:) = WFEmpty;  % fill the output with NaNs	end% next do the PSF metrics (no threshold, it was done above)	if metricType(2)		if exist('doit','var')            [Y,fid,mask,newCoreMask,psfDLnorm]=PSFMetrics(PSF,spaceHalfwidth*x,...                spaceHalfwidth*y,PupilD,lambda,showit,0,doit(:,2),[],DL_PSF);			PS(j,:) = Y;            % the metric values            psfMarkers(j,:) = fid;  % fiduciary points		else			[Y,fid,mask,newCoreMask,psfDLnorm]=PSFMetrics(PSF,spaceHalfwidth*x,...                spaceHalfwidth*y,PupilD, lambda, showit, 0,[],[],DL_PSF);			PS(j,:) = Y;            % the metric values            psfMarkers(j,:) = fid;  % fiduciary points		end				else        PS(j,:) = PSEmpty;  % fill the output with NaNs        psfDLnorm = ones(1,numberMetrics(2));   % place holders    end% last, do the OTF metrics    rMTF=[]; rOTF=[];	if metricType(3) 		if exist('doit','var')			[Y2,otfDLnorm,rSF,rMTF,rOTF,CSF,sfCSF]=OTFMetrics(OTF,x*bandwidth,...                y*bandwidth,PupilD,lambda, showit,doit(:,3));            SF(j,:) = Y2;		else			[Y2,otfDLnorm,rSF,rMTF,rOTF]=OTFMetrics(OTF,x*bandwidth,...                y*bandwidth,PupilD,lambda, showit);            SF(j,:) = Y2;        end	            else        SF(j,:) = SFEmpty;  % fill the output with NaNs        otfDLnorm = ones(1,numberMetrics(3));   % place holders	end	if saveit	% save any intermediate results of interest		Wstack(:,:,j)=W;        % wavefront maps		PSFstack(:,:,j)=PSF;    % point spread functions		OTFstack(:,:,j)=OTF;    % optical transfer functions		xstack(:,:,j)=x;        % support for W, PSF, OTF		ystack(:,:,j)=y;        % support for W, PSF, OTF		bwstack(j)=bandwidth;   % bandwidth calibration        if ~isempty(rOTF), radialOTF(:,j)=rOTF; end   % radial OTF        if ~isempty(rMTF),radialMTF(:,j)=rMTF; end   % radial MTF        % note: rSF = radial SF (cyc/deg) for radialOTF and radialMTF    end% showit = true;	if showit, 	% give user a chance to see diagnostic figures        % Graph_Zc2psf2otf - replace this script by a function w/args        show_Zc2psf2otf(W,pupilMask,PSF,OTF,x,y,spaceHalfwidth,bandwidth);    end        waveDLnorm = ones(1,numberMetrics(1));    DLnorm(rr,:) = [waveDLnorm psfDLnorm otfDLnorm]; %assemble a denormalizing vectorendif logical(saveit) 	QM = [WF,PS,SF]; % concatenate metrics into a row vector or matrix of row vectors	save QMresults 	% save workspace, rename QMresults at OS level to preserve these results    disp('File QMresults.mat has been created. Rename at OS level to save.')end