function [Tx,Ty,LA,D2,TG]=showdWdx(Wxy, x, y, mask, calib, num, showit)%show_dWdx - show spatial derivatives of wavefront aberrations function 7 ways% % use: [Tx,Ty,LA,D2,TG]=showdWdx(W,x,y,mask,calib,num,showit)%% input:  %		W = wavefront in units of microns%		x,y = support mesh, in physical units (mm) in pupil plane%		mask = mask to be applied to (x,y). Pts outside mask are set to NaN%		calib = 1x4 vector of calibration values for plotting =[W,TA,LA,Curv]%				default = [1 1 1 1].  Calib pixels are in lower left corner of image.%		num = number of arrows to show in quiver plot (default = 5)%       showit = 1 for multipart figs, =-1 for individual figs, =0 for no graphs%% output:%   Tx,Ty = transverse ray aberration, in microns/mm = milliradians%   sign convention: T>0 => wavefront points towards z-axis %   LA = Longitudinal aberration = (dW/dr)/r, in mrad/mm = rad/m = diopters%   D2 = local dioptric power derived from Laplacian of W%   TG = tangential aberration = (dW/dt)/r, in mrad/mm = rad/m = diopters%% graphical display:%   fig 1 = 6 part fig showing wavefront, x- and y- derivatives, ray%     aberrations (as quiver plot), longitudinal dioptric and curvature%     dioptric maps%   fig 2 = 4-part fig showing horizontal & vertical slopes, radial slope,%     and ray aberrations as quiver plot%   fig 3 = 4-part fig showing horizontal & vertical slopes, spot diagram,%     and ray aberrations as quiver plot%%LNT 19-Mar-00% LNT 03-FEB-02 Added a new figure to show second partial derivatives in x,y.  Also discovered%  that calibration of curvature map was too big by factor of two.  Test case is pure defocus, %  which should give same longitudinal aberration as curvature (e.g. 0.38 D for 6mm pupil, 0.5 micron aberr).% LNT 13-Nov-07.  Rearrange graphics and redefine input parameter "showit"% LNT 14-Dec-07.  Remove calibration values from returned matrix LA    % set up defaults    if nargin<7 || isempty(showit), showit = 1; end    if nargin<6 || isempty(num), num = 5;	end		% default = 1mrad, 1diopter, 1diopter    if nargin<5 || isempty(calib), calib = ones(1,4);	end		% default = 1mrad, 1diopter, 1diopter       [rows, cols] = size(x);			% this should be true for all input matrices    xc = round(rows/2);				% go to center of function to get step size    yc = round(cols/2);    xstep = x(xc,1+yc) - x(xc,yc);	% x-distance between sample points in pupil, in mm    ystep = y(1+xc,yc) - y(xc,yc);	% y-distance between sample points in pupil, in mm    m = find(mask);					% mask index    R = sqrt(x.^2+y.^2);			% radial support mesh    middle = find(R <= eps*1E6);	% find troublesome middle of pupil    [I,J] = ind2sub(size(R),middle);    % Gradient gives transverse aberration, in microns/mm = milliradians    % sign convention: T>0 => wavefront points towards z-axis     [Tx, Ty] = gradient(Wxy, xstep, ystep);    Tx(mask == 0) = NaN;            % a trick to avoid plotting outside pupil	    Ty(mask == 0) = NaN;            % a trick to avoid plotting outside pupil    % Longitudinal aberration = TA/pupil height, in mrad/mm = rad/m = diopters    % Plot LA in meridional plane as best approximation in case rays are skew to optical axis    % sign convention: LA>0 => converging rays point towards z-axis     % sign convention: TG>0 => tangential rays point in clockwise direction        L = zeros(rows,cols); Mer=L; Tang=L; Tg=L;    R(middle) = xstep;                                      % temporarily replace the point of singularity    Mer(m) = (x(m).*Tx(m) + y(m).*Ty(m)) ./ R(m);           % project TA onto unit radial vector = meridional slope    L(m) = Mer(m) ./ R(m);                                  % divide by ray height in radial direction to get diopters    L(middle) = L(middle+1);                                % assume function is continuous at origin    L(I,J) = (L(I,J+1)+L(I,J-1)+L(I+1,J)+L(I-1,J))/4;       % assume function is continuous at origin    LA=L;                                                   % a copy to return to user    Tang(m) = (-y(m).*Tx(m) + x(m).*Ty(m)) ./ R(m);         % project TA onto unit tangential vector = tangential slope    Tg(m) = Tang(m) ./ R(m);                                % divide by ray height in radial direction to get diopters    Tg(middle) = Tg(middle+1);                              % assume function is continuous at origin    Tg(I,J) = (Tg(I,J+1)+Tg(I,J-1)+Tg(I+1,J)+Tg(I-1,J))/4;	% assume function is continuous at origin    TG=Tg;   % a copy to return to user    % Laplacian gives curvature map =local dioptric power    % Note: del2 returns (d^2u/dx^2 + d^2/dy^2)/4, but we want 2x this, which is average second deriv.    % 03-Feb-02.  Evidently this reasoning is wrong. Don't double the results.    D2 = zeros(rows,cols); DX = D2; DY = D2;    % Del2 = del2(W,xstep,ystep);     [Del2,DelX,DelY] = del2LNT(Wxy,xstep,ystep);     % size(Del2), size(DelX), size(DelY), size(m)    %Del2=Del2; DelX=DelX; DelY=DelY;    D2(m) = 2*Del2(m);    %DX(m) = 2*DelX(m);    %DY(m) = 2*DelY(m);    %DXY=(DX+DY)/2;    %minmaxD = [min(D2(:)), max(D2(:))];end