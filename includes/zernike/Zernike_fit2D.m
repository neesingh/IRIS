function z = Zernike_fit2D(W,X,Y,modes,verbose)%Zernike_fit2D	Compute Zernike coefficients from 2-D sampled wavefront %%   Use: z = Zernike_fit2D(W,X,Y,modes,verbose);%%	Input arguments:%		W = sampled wavefront to be analyzed.  NaN => missing data%		X = matrix of X-locations of sample points, normalized coordinates%		Y = matrix of Y-locations of sample points, normalized coordinates%       note: W, X, and Y can be vectorized matrices (e.g. W(mask))%		modes = vector of modes to be used as basis fns. default = 1:66%		verbose = switch to turn on diagnostic printing (1=default) or turn off (0)%%	This uses ZernikeR.m to compute the Zernike matrix to 66 modes.%	Convention: Piston = mode 1%%	3/18/98 Tom Salmon%  	LNT 18-Mar-98  Make this a function to enable testing. Assume unit circle.%	LNT 6-Apr-98 Add 4th arg & tidy up a bit.%	LNT 11-Mar-00.  This routine does not get the correct answer for modes 1,5,13 etc.%	  This can be demonstrated by choosing a unit vector in one of these directions, %		using it to generate a wavefront with Zvec2Wxy.m, then analyzing this wavefront%		with Zernike_fit2D.  The result has the wrong piston term.% Example code: 	[x,y,W,Mask]=Zvec2Wxy([0 0 0 0 1 0]);%					z = Zernike_fit2D(W,x,y,1:6,0)%	LNT 22-Apr-02.  Realized that this routine DOES get it right, IF the call to Zvec2Wxy%		requests the true waveform, not the wavefront error.% Note that pupil size is not needed to get Z-coeffs.  Evidently this is because W is already %  in physical units of microns, so the coeffs will be in microns, too.%% Example code: 	[x,y,W,Mask]=Zvec2Wxy([0 0 0 0 1 0],1:6,0.02,1,'h');%					z = Zernike_fit2D(W,x,y,1:6,0)%% See also: ZERNIKER%% LNT 7Sep06 modify def of "valid" to skip NaNs in the wavefrontif nargin <5 || isempty(verbose),	verbose = 1;	end;	% default = verbose reportingif nargin <4 || isempty(modes),	modes = 1:66;	end;	% default = maximum # of modes allowed%	Vectorize input matrices.%	[m,n]=size(X);	len = length(modes);	xv = X(:);	yv = Y(:);	wv = W(:);	rv = xv.^2+yv.^2;%	Use only points inside the pupil. 7Sep06 skip NaNs in the wavefront	valid = find(rv<=1 & ~isnan(wv));	% get indices of points inside unit circle    xx = xv(valid);    yy = yv(valid);    ww = wv(valid);	k = max(size(xx));%	msg = ['Zernike_fit2D: Number of valid sample points = ', num2str(k)]%	Compute [k,modes] matrix (A) of Zernike terms evaluated at X & Y	for j = 1:max(size(modes));			A(:,j) = zernikeR(xx,yy,modes(j),'h');		end	%	Compute Zernike coefficients%	msg = 'z = vector of Zernike coefficients'	z = A\ww;if verbose==0, return;	end;	% quick exit		z'	% type the results%	Find mean value and variance in origial wavefront data	Wmean = mean(ww);	Wvariance = std(ww).^2;%	Find sum of modal variances based on Zernike coefficients	zSquared = z.^2;	if length(find(modes==1))		temp=find(modes ~=1);	% locate non-piston terms		SoScoeffs = sum(zSquared(temp)); 	% omit PISTON (mode 1)	else		SoScoeffs = sum(zSquared(1:len)); 	%mode 1 is not analyzed	end		%	Reconstruct wavefront & compute variance for each Zernike mode	a_mask = z*ones(1,length(z)).*eye(length(z));		% a_mask is a matrix with the z-coefficients along the diagonal	wz_modes = A*a_mask;		% wz_mades is a matrix with reconstruct W for each mode in each column.		% Column 1 corresponds with mode 1, etc.		% Each row corresponds a sampled point.	wz_total = wz_modes*ones(length(z),1);		% Sum the reconstructed W across modes	mode_var = (std(wz_modes,1).^2)';	mode_var'	%type the results%	Compare results of two methods for accounting for variance of wavefront		mode_by_mode_err=(zSquared - mode_var)' % should be zeros, except for piston term	% 	Compute wavefront variance within each reconstructed mode	SoModalVar = sum(mode_var);	%VAR(PISTON)=0 always, so can include in sum	%	Report the three ways of computing variance of wavefront		msg = 'Compare three ways of computing variance of wavefront'	msg = ['Variance of input waveform = ', num2str(Wvariance)]	msg = ['Sum of Squared z-coefficients = ', num2str(SoScoeffs)]	msg = ['Sum of Modal Variances = ', num2str(SoModalVar)]	%	See how reconstructed W compares with original W.	RMSerror = std(wz_total - ww,1);	msg = ['RMS error of fitting = ', num2str(RMSerror)]%	Bookkeeping: mode variances should add up to variance of original waveform	CompareVar1 = 100*SoScoeffs/Wvariance;	msg = ['Percent of Data Variance accounted for by Z-coef= '...	, num2str(CompareVar1)]	CompareVar2 = 100*SoModalVar/Wvariance;	msg = ['Percent of Data Variance accounted for by modal variances = '...	, num2str(CompareVar2)]	% 	View the reconstructed wavefront	ZW = 0*wv;					% a copy of starting wavefront, in vector form	ZW(valid) = wz_total; 		% reconstruct in vector form	ZW = reshape(ZW,size(W));	% make it a square matrix	figure;	imshow(mat2gray(ZW));					% display the synthesized data    title('Zernike_fit2D: Wavefront')		figure;	delta = W - ZW;	imshow(mat2gray(delta));					% display the error    title('Zernike_fit2D: fit error')%	std(delta(:))	%out = [RMSerror, CompareVar1, CompareVar2];% end of function Zernike_fit2D