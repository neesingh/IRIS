function F=Zernike2Fourier(z,a,order)% Zernike2Fourier: Convert normalized Zernike vector to spectacle Rx in Fourier form.% Per optometric conventions, F is the lens required to correct eye with%   measured aberrations specified in vector z.%% Use: F=Zernike2Fourier(z,a,order)%%  Fourier form of spectacle presecription (Rx) is given in:%  	 L. N. Thibos, W. Wheeler, and D. G. Horner, %  	"Power vectors: an application of Fourier analysis to the%	 description and statistical analysis of refractive error" %	 Optom. Vis. Sci. 74, 367-375 (1997).%%  Basis for conversion is outlined in section 3.3 of draft chapter%   of Handbook of Visual Optics by L.N. Thibos and in Chapter 19 of%   Borish's Clinical Refraction (second edition, Benjamin editor)%% input args:	%	z = col vector of normalized Zernike coefficients (must NOT be sparse)%		or a matrix of column vectors.%	Note: to deal with sparse input vectors, should re-write this routine% 		to call on function Zvec2Zmat to parse the vector into orders,%		then extract the second-order coefficients from pyramid matrix.%%	a = pupil radius (scalar or a row vector with same # cols as in z)%%	Units: if pupil radius is in mm and Zernike coefficients in microns%		  then the Fourier vector of dioptric powers will be in diopters.%%   order = highest Zernike order to include in calculation. default = 2%     Any order is possible. Zero means return all zeros. Odd integers mean%     average the order above with the order below.%% output variables:%	F = Fourier col vector [M;J0;J45] or a matrix of Fourier columns%% required user functions:  Znorm.%% related functions: Fourier2Zernike, Fourier2Spex, Spex2Fourier%% LNT 31-Mar-99% LNT 16-Nov-99.  Verified this function is consistent with VSIA standards. No changes					% required of 31-Mar version.% LNT 9-Apr-01.  Corrected a flub in handling of z=matrix of input vectors% LNT 2-Oct-01.  Allow pupil radius to be a vector of values% LNT 5-Mar-02.  Have come to realize that this standard solution can be viewed as a %  Seidel (paraxial) solution when highest aberration present is second order.  If higher%  orders are present, then the Seidel coefficient is computed from a linear combination%  of the even order Zernike coefficients of zero meridional frequency.  I've worked this%  out for defocus, but not yet for astigmatism.% LNT 5Aug02.  Add code to evaluate 4th and 6th order estimates of J0 and J45% LNT 6Dec05. Add hybrid cases 3 (average of 2&4) and 5 (average of 4&6)% LNT 19Mar06. Add options for order = 0 or 1. Omit legality checking.% LNT 05Aug2014. Redefine order 0 as minRMS refraction for small pupil. %  The concern is that paraxial/Seidel solution may not be representative %  of a small human pupil, which never gets smaller than 2mm diameter.% © 2001, 2002, 2003 Larry Thibos, Indiana Universityif nargin <3, order=2; enddisp(['Z2F order = ',num2str(order)])% if (order ~= 2) & (order ~= 4) & (order ~= 6) % 	error('Parameter "order" must have value 2,4, or 6')% 	end;[rows,cols]=size(z);		% rows = #modes, cols = # vectorsif length(a) ~=1;			% legality check	if length(a) ~= cols;		error('Length of second arg must equal # cols in first argument');	endend%modes = 1:length(z);		% rebuild a vector of mode numbersmodes = 1:rows;				% rebuild a vector of mode numbersn = ones(1, cols);Zn = Znorm(modes')*n;		% matrix of repeated columnsZ = z.*	Zn;					% un-normalize the Zernike coefficientssmallPupilRadmm = 1;      % try a 2mm pupil approximation to paraxialswitch ordercase 0% 	M = 0;		% by convention, 0-order means zero power for all 3 terms% 	J0 = 0;		% 	J45 = 0;% new convention: find 2nd order power vector for small pupil    modeSequence = [1  3  6  10  15  21  28  36];    Zorder = find(size(z,1)==modeSequence) - 1; % highest order in z    B=scalePupil(z',a,smallPupilRadmm, Zorder);    F=Zernike2Fourier(B',smallPupilRadmm,2); % recursive call to this program    returncase 1	M = -2*Z(5,:)./(a.*a);		% NOT average cases 0 & 2	J0 = -Z(6,:)./(a.*a);			J45 = -Z(4,:)./(a.*a);		case 2	M = -4*Z(5,:)./(a.*a);		% assert the equality of corresponding terms	J0 = -2*Z(6,:)./(a.*a);		% and do all the columns at once	J45 = -2*Z(4,:)./(a.*a);	% oblique (sine) JCCcase 3	if rows < 13, 		M=NaN; 		J0=NaN;		J45=NaN;	else		M = (-4*Z(5,:)+6*Z(13,:))./(a.*a);	% average cases 2&4		J0 = (-2*Z(6,:)+3*Z(14,:))./(a.*a); 		J45 = (-2*Z(4,:)+3*Z(12,:))./(a.*a); 	endcase 4	if rows < 13, 		M=NaN; 		J0=NaN;		J45=NaN;	else		M = (-4*Z(5,:)+12*Z(13,:))./(a.*a);	% include 4th order contribution		J0 = (-2*Z(6,:)+6*Z(14,:))./(a.*a); 		J45 = (-2*Z(4,:)+6*Z(12,:))./(a.*a); 	endcase 5	if rows < 25, 		M=NaN;		J0=NaN;		J45=NaN;	else 		M = (-4*Z(5,:)+12*Z(13,:)-12*Z(25,:))./(a.*a);	% average cases 4&6		J0 = (-2*Z(6,:)+6*Z(14,:)-6*Z(26,:))./(a.*a);  		J45 = (-2*Z(4,:)+6*Z(12,:)-6*Z(24,:))./(a.*a);	endcase 6	if rows < 25, 		M=NaN;		J0=NaN;		J45=NaN;	else 		M = (-4*Z(5,:)+12*Z(13,:)-24*Z(25,:))./(a.*a);	% include 4th & 6th order contribution		J0 = (-2*Z(6,:)+6*Z(14,:)-12*Z(26,:))./(a.*a);  		J45 = (-2*Z(4,:)+6*Z(12,:)-12*Z(24,:))./(a.*a);	endendF = [M; J0; J45];			% 3 rows, each col is a Fourier vector% end of function Zernike2Fourier