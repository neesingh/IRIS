function [out]= zernike2psf(cf, z, r, lambda, s)%%% zernike2psf: optical transfer function (OTF) and point-spread function% (PSF) from Zernike aberration coefficients or a wavefront aberration function.%% Adapted from Š 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009% Larry Thibos, Indiana University by Matt Jaskulski, University of Murcia%% Adapted and developed by Matt Jaskulski, University of Murcia Š 2015%%% set up default variables    tic;    ui_defaults = getappdata(cf, 'ui_defaults');        out = struct();        rotate_chief_ray= s.rotate_chief_ray;                        %   default = 1, fix the chief ray to be the z-axis by rotating the wavefront    %pupil_area = ui_defaults.pupil_area;    pupil_area = 1;    pupil_bits = ui_defaults.pupil_bits;                        %   bits used to represent Pupil Function (e.g. N=7 for                        %   128x128; N=8 for 256x256). Default = 7.                         %   note: increasing N increases the frequency resolution                        %   of OTF and increases spatial width of PSF    	pupil_ellipticity = s.pupil_ellipticity;                        %   Default = 0 (circular pupil).                            pupil_rotation = s.pupil_rotation;                        %   0 is a horizontal ellipse and 90 a vertical one                         	pupil_sce = s.pupil_sce;                        %   Stiles-Crawford pupil apodization factor in the equation: exp(-alpha*r^2). Default = 0. Typical human value is 0.115 mm^-2                            lambda = lambda * 1e-9;    reference_lambda = s.reference_lambda * 1e-9;                        % [m] wavelength for scaling the sampling mesh that supports the pupil function                         % default = lambda to achieve prior functionality (i.e full resolution of pupil function for the test wavelength)                         % Since the number of sample points across the pupil function = 128*reflambda/lambda, a good choice for reflambda is                        % 0.4e-6 to get the full resolution (128 sample points) for a given test wavelength lambda.     pupil_support = 2^(pupil_bits-1);           % reduce N by 1 because array is double-sided    lambda_ratio = lambda/reference_lambda;     % Effect of wavelength-dependent pupil resolution on size of returned vars:                                                % if lambda ~= reflambda, then Wxy,PF,xp,yp,Axy are all reduced in                                                 % size by factor lambda/reflambda. They could easily be padded out to                                                 % next power of 2 using padmatrix if required.                                                  % Numerical values of scalars spaceHalfwidth,bandwidth, are unaffected                                                % even though the DL cutoff changes with wavelength. Tested with test_Zc2psfV2.m                                                    % Notes on units:   multiply x,y by spaceHalfwidth to put support for PSF into physical units (arcmin).    %                   multiply x,y by bandwidth to put support for OTF into physical units (cyc/deg).    %                   multiply xp,yp by PupilDia/2 to put support for Wxy, PF into physical units (m).        % Let resolution of pupil mesh vary with wavelength so that sample mesh for PSF and OTF are independent of wavelength. This avoids    % having to interpolate results onto a common grid in polychomatic case.    k = 2*pi/lambda;        v = (-pupil_support:lambda_ratio:pupil_support-1)/pupil_support; %asymm.    [x,y] = meshgrid(v);	                                          		        % In the case of elliptical pupils, Zernike coeffs or the wavefront input is interpreted as existing over a    % circlular pupil. This optical system is then viewed through an elliptical pupil with aspect ratio = pupil_aspect    % For the pupil function Axy*exp(iWxy), Axy is the pupil mask.          pupil_support = elliptical_pupil(x, y, pupil_rotation, pupil_ellipticity);               Axy = pupil_support <= pupil_area;    xp = x; yp = y;           if(sum(z) == 0)        Wxy = zeros(size(x));       % performance tweak for polyPSF calculations    else        if isvector(z)            % reconstruct the wave aberration function from Zernike coefficients using pre-computed basis functions.             modes = length(z);            if modes==6                ZernBasis = zernikeR_6(x,y);	            elseif modes==10                ZernBasis = zernikeR_10(x,y);	            elseif modes==15                ZernBasis = zernikeR_15(x,y);	            elseif modes==21                ZernBasis = zernikeR_21(x,y);	            elseif modes==28                ZernBasis = zernikeR_28(x,y);	            elseif modes==36                ZernBasis = zernikeR_36(x,y);	            elseif modes==45                ZernBasis = zernikeR_45(x,y);	            elseif modes==55                ZernBasis = zernikeR_55(x,y);	            elseif modes==66                ZernBasis = zernikeR_66(x,y);            else                show_msg(cf, sprintf('Number of modes (%s) is not standard', modes), 'error');            end            Wxy = zeros(size(x));                       % initialize the wavefront            for j = 1:modes                             % accumulate Wxy by summing basis functions                Wxy = Wxy + ZernBasis(:,:,j) * z(j);    % scaled by coeffs            end            clear ZernBasis;        end        if rotate_chief_ray == 1            % r_min = 0.02;  % criterion value for paraxial analysis = circle 16 pix diam = 153 points            r_min = 0.01;   % criterion value for paraxial analysis = circle 12 pix diam = 81 points (is it for N = pupil_bits = 7 bits?)            paraxial_xy = (xp.^2 + yp.^2) <= r_min;     % a paraxial pupil            paraxial_xy = find(paraxial_xy > 0);        % pointers to the valid data            [Wxy, ~] = wavefront_rotate(Wxy, xp, yp, paraxial_xy);  % make chief ray = z-axis(04Jan09)            %show_msg(cf, ['Chief ray prism (', num2str(zernike_prisms(2)), ', ', num2str(zernike_prisms(3)),') corrected.']);            %if std(Wxy(paraxial_xy)) > 0.01, show_msg(cf, 'Wxy rotate: parax RMS > 0.01 microns', 'warning'); end        end    end        if(~isempty(s.add_Wxy) && sum(z)~= 0) % the sum of Zernikes is zero when computing the diff. limited PSF, where we don't want to add any Wxy        Wxy_add = s.add_Wxy;        Wxy_add(isnan(Wxy_add)) = 0;                scale_px = size(Wxy)/size(Wxy_add); % 256px / 257px        scale_mm = s.add_Wxy_radius * s.add_Wxy_scale / r; %        scale = scale_px * scale_mm;                Wxy_add = imresize(Wxy_add, scale);                row_diff = size(Wxy,1) - size(Wxy_add,1);        col_diff = size(Wxy,2) - size(Wxy_add,2);                padValue = Wxy_add(1,1);                if(row_diff > 0)                        Wxy_add = padarray(Wxy_add, [floor(row_diff/2), 0], padValue, 'pre');            Wxy_add = padarray(Wxy_add, [round(row_diff/2), 0], padValue, 'post');            row_diff = 0;                    end                if(col_diff > 0)                        Wxy_add = padarray(Wxy_add, [0, floor(col_diff/2)], padValue, 'pre');            Wxy_add = padarray(Wxy_add, [0, round(col_diff/2)], padValue, 'post');             col_diff = 0;                    end                if(row_diff < 0 || col_diff < 0)            offset = floor((size(Wxy_add) - size(Wxy))/2);            Wxy_add = Wxy_add(  offset(1):offset(1)+size(Wxy,1)-1,...                                offset(2):offset(2)+size(Wxy,2)-1);                    end                  Wxy = Wxy + Wxy_add;                se = strel('square', 5);        Axy = imerode(Axy, se);            end     if(s.calculate_psf == 1)                % Apply the Stiles Crawford effect. Updated to respect ellipticity of the pupil        if(pupil_sce ~= 0)            sce = 0.5*pupil_sce*r.^2;                   % Gaussian amplitude apodization             Axy = Axy.*exp(-sce*pupil_support);         % pupil apodization array        end        if(~isempty(s.pupil_mask))            %pupil_mask = imresize(s.pupil_mask(:,:,rgb), size(Axy));            pupil_mask = imresize(s.pupil_mask(:,:,1), size(Axy));            %figure(rgb+100); imshow(pupil_mask);                                                        % the usage of rgb here aims to simulate the effects of                                                        % yellowing of the lens by cataract as experienced by Claude Monet            Axy = Axy .* pupil_mask;        end        % create the pupil function        PF = Axy .* exp(1i*k*Wxy*1e-6);        % compute physical scaling factors         [psf_halfwidth, psf_bandwidth, psf_pix_halfwidth, cutoff_freq] = psf_scaling_factors(cf, r, lambda);        psf_resolution = psf_halfwidth/psf_pix_halfwidth;        % generate support meshgrids for PSF and OTF        vv = (-psf_pix_halfwidth:1:(psf_pix_halfwidth -1))/psf_pix_halfwidth;	% asymmetric meshgrid, includes origin        [x,y] = meshgrid(vv);        psf_support = elliptical_pupil(x, y, pupil_rotation, pupil_ellipticity);        pupil_shape = psf_support < pupil_area;                if(s.calculate_psf_go == 1)            idx = find((xp.^2+yp.^2) <= pupil_area);    % indices into pupil (avoid edge effects)                        xstep = r*(xp(1,2)-x(1,1));                 % x-distance between samples,mm            ystep = r*(yp(2,1)-y(1,1));                 % y-distance between samples                        % Gradient gives transverse aberration, in microns/mm = milliradians            % sign convention: T>0 => wavefront points towards z-axis             [Tx,Ty] = gradient(Wxy,xstep,ystep);        % gradient in mRad            Tx = Tx(idx); Ty = Ty(idx);                 % trim to valid pupil locations            spots = 3.4377*[Tx,Ty];                     % coordinates of each spot,arcmin            ss = 1;                                     % a subsample integer            xbins = x(1,(1:ss:end));                    % bins in normalized coordinates            xbins = xbins + (xbins(2)-xbins(1))/2;      % convert to bin centers            xbins = psf_halfwidth*xbins;                % convert to physical units            ybins = y((1:ss:end),1);            ybins = ybins + (ybins(2)-ybins(1))/2;      % convert to bin centers            ybins = psf_halfwidth*ybins;                % convert to physical units                        % ---------- Obtain the PSF -----------            PSF = hist3(spots, {xbins ybins});          % bin the spots            % ---------- Obtain the PSF -----------                        PSF = PSF';                                 % rotate 180deg to match PSF, see hist3_LNT for notes on why the histogram needs transposing            PSF = rot90(PSF,2);                    else % use Fourier Optics            ASF = ifft2(PF, 2*psf_pix_halfwidth, 2*psf_pix_halfwidth);  % amplitude spread function             % ---------- Obtain the PSF -----------            PSF = ASF.*conj(ASF);                           % intensity spread function, not centered            % ---------- Obtain the PSF -----------            PSF = fftshift(PSF);                            % center the origins of PSF & OTF for display purposes        end                PSF = flipud(PSF);                  % I am clueless as to why this is necessary, but with everything else exactly the same the IS and FOC                                            % give exactly the same results, save for this, even using the old zc2psf2otf.m.                psf_volume = sum(PSF(:));                PSF = PSF./psf_volume;              % normalize to unit volume        % disp(['maxotf= ', num2str(max(max(abs(OTF))))]);      % diagnostic: should be unity since volume of PSF = 1          % apply optical constraint that OTF = 0 beyond the cutoff freq.        otf_mask = psf_support <= (cutoff_freq/psf_bandwidth);      % 1 for all freq < cutoff        otf_mask = otf_mask.*pupil_shape;                           % tidy up points outside unit circle        % Fourier transform PSF to get Optical Transfer Function (OTF). Because PSF is real-valued,        % OTFs have conjugate symmetry (i.e. the real part has even symmetry and the imaginary part has odd symmetry).        OTF = fft2(PSF);        OTF = fftshift(OTF).*otf_mask;                PSF = real(PSF);                                    % omit nuisance imaginary part due to rounding errors         %out.PF = PF;        out.OTF = OTF;        out.PSF = PSF;        out.otf_mask = otf_mask;        out.psf_volume = psf_volume;        out.psf_support = psf_support;        out.psf_pix_halfwidth = psf_pix_halfwidth;        out.psf_halfwidth = psf_halfwidth;        out.psf_bandwidth = psf_bandwidth;           out.psf_resolution = psf_resolution;                % spatial width of 1 pixel in PSF in arcmin BEFOREEEEEEEEEEE resizing!                                                            % so it applies to PSF_cropped and PSF matrices and NOT to PSF_resized                                                            % I mentally discovered it while running so its kind of awesome.        out.cutoff_freq = cutoff_freq;        out.psf_x = x;        out.psf_y = y;        out.toc_zernike2psf = toc;                          % its better to burn out than to fade away!       end % end if calculate psf    out.Wxy = Wxy;    out.pf_x = xp;    out.pf_y = yp;    out.Axy = Axy;end