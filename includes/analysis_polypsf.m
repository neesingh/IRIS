function [ analyses, s ] = analysis_polypsf( ~, ~, s )% Parts based upon the Fourier Optics Calculator © 2004 Larry Thibos, Indiana University% This script calculates an RGB color image from polyPSF calculations.% Starts with 3 polychromatic PSFs for 3 guns of an average CRT display, using% 3 different radiance spectra. Uses a colored object such as a jpg picture% and convolve the three layers separately with the respective poly PSFs.% Puts the 3-layer polychromatic blurred image back together again and% render in color. % Primary Reference for the used method is JOSA methods paper Oct 2008. % Sowmya, April 2012% Modified from earlier versions for Ostendo Technologies%% Adapted and developed for the Imaging Simulator by Matt Jaskulski, University of Murcia © 2015%%%   To-do's and developer's notes:%   - I am missing the ConvertWavelength function. It's used when lca_switch is not 1 (which is never the case) so I'm removing all that code.%   - I discarded the variable lambda snippet. I'm not sure what purpose does this functionality serve.%    cf = s.cf;        show_msg(cf, t('Working, Please Wait...'));        ui_handles = getappdata(cf, 'ui_handles');      % all of the uicontrols of the launcher    ui_defaults= getappdata(cf, 'ui_defaults');     % basic settings available via the settings panel        WXYZ = [];    load('WXYZCIE31JV.mat', 'WXYZ'); % contains WXYZ, wxyz. See XYZJuddVoss.m for details    if(s.selected_zernike == 5)        s.selected_zernike_value = microns2diopters(s.selected_zernike_value, s.r);         sweep_diopters = s.analysis_range;                       % a vector of spherical powers [D]        sweep_diopters(2:3,:) = 0;                               % add two rows of zeros        sweep_diopters = -Fourier2Zernike(sweep_diopters, s.r);  % convert spherical refraction to Zernikes        sweep_microns = zeros(1, length(s.analysis_range));    else        sweep_diopters = zeros(5, length(s.analysis_range));     % just a zero matrix        sweep_microns = s.analysis_range;    end        if(s.include_vlambda ~= 1)                WXYZ(:,3) = ones(size(WXYZ,1),1);            end        % Poly PSF mode-specific settings    spd_type = get(ui_handles.spd_dropdown, 'Value');    s.spd = SPD(spd_type);    %% Poly PSF for Imaging Simulator implementation    lambdas = s.spd(end,1) - s.spd(1,1);    lambdas = lambdas/(s.no_psfs+1);    lambdas = s.spd(1,1)+lambdas:lambdas:s.spd(end,1)-lambdas;    %lambdas = [400:50:700]; % Sowmya's        no_lambdas = length(lambdas);           % lambdas are slices that we take of the spectrum - same set of slices for each R G B channel    no_analyses = length(s.analysis_range);   % analyses are all the through-zernike steps that we are calculating        if(spd_type == 1)        no_channels = 1;    else        no_channels = size(s.spd,2)-1;          % channels are what we have the radiance spectrums defined for, usually 3    end        % interpolate the SPD as to obtain radiance values for lambdas of interest    radiances = zeros(no_lambdas, no_channels);    for i = 1:no_channels          radiances(:, i) = interp1(s.spd(:, 1), s.spd(:, i+1), lambdas);    end    s.spd = radiances;    % compute the offset caused by the device lambda / reference lambda difference                                                         offset = IndianaEye(s.device_lambda/1000, 1, s.reference_lambda/1000, s.lca_switch, s.qp) + s.offset;    offset(2:3,:) = 0;                              % convert Rx to a matrix of column power vectors    offset = Fourier2Zernike(offset, s.r);          % convert F to matrix of col Z-vectors        % compute vector of refractive errors for longitudinal chromatic aberration    LCAs = IndianaEye(lambdas/1000, 1, s.reference_lambda/1000, s.lca_switch, s.qp);    LCAs = LCAs * s.lca_multiplier;        % ARTHUR AUG2018        %wavelengths = [0.45,0.451833,0.453667,0.4555,0.457333,0.459167,0.461,0.462833,0.464667,0.4665,0.468333,0.470167,0.472,0.473833,0.475667,0.4775,0.479333,0.481167,0.483,0.484833,0.486667,0.4885,0.490333,0.492167,0.494,0.495833,0.497667,0.4995,0.501333,0.503167,0.505,0.506833,0.508667,0.5105,0.512333,0.514167,0.516,0.517833,0.519667,0.5215,0.523333,0.525167,0.527,0.528833,0.530667,0.5325,0.534333,0.536167,0.538,0.539833,0.541667,0.5435,0.545333,0.547167,0.549,0.550833,0.552667,0.5545,0.556333,0.558167,0.56,0.561833,0.563667,0.5655,0.567333,0.569167,0.571,0.572833,0.574667,0.5765,0.578333,0.580167,0.582,0.583833,0.585667,0.5875,0.589333,0.591167,0.593,0.594833,0.596667,0.5985,0.600333,0.602167,0.604,0.605833,0.607667,0.6095,0.611333,0.613167,0.615,0.616833,0.618667,0.6205,0.622333,0.624167,0.626,0.627833,0.629667,0.6315,0.633333,0.635167,0.637,0.638833,0.640667,0.6425,0.644333,0.646167,0.648,0.649833,0.651667,0.6535,0.655333,0.657167,0.659,0.660833,0.662667,0.6645,0.666333,0.668167,0.67];    %tecnis = [-0.666476127,-0.650128167,-0.633983814,-0.61803945,-0.602291484,-0.58673646,-0.571370895,-0.556191522,-0.541195047,-0.526378284,-0.511738128,-0.497271474,-0.482975406,-0.468846954,-0.454883283,-0.441081585,-0.427439106,-0.413953227,-0.400621248,-0.387440658,-0.374408946,-0.361523601,-0.348782274,-0.336182589,-0.323722197,-0.311398911,-0.299210463,-0.287154693,-0.275229468,-0.263432736,-0.251762445,-0.240216597,-0.228793221,-0.217490427,-0.206306298,-0.195239025,-0.184286799,-0.173447811,-0.16272036,-0.152102745,-0.141593292,-0.131190354,-0.120892365,-0.110697678,-0.100604835,-0.090612243,-0.080718498,-0.070922061,-0.061221582,-0.051615603,-0.042102747,-0.032681718,-0.023351139,-0.014109741,-0.004956228,0.004110642,0.013092111,0.021989367,0.030803598,0.039535965,0.048187629,0.056759697,0.065253276,0.073669446,0.08200926,0.090273771,0.098464032,0.106580988,0.114625665,0.122599035,0.130502043,0.138335634,0.146100753,0.153798237,0.161429058,0.168994053,0.176494059,0.183929967,0.191302587,0.198612729,0.205861203,0.213048792,0.220176279,0.227244447,0.234254025,0.241205769,0.248100381,0.25493859,0.261721098,0.26844858,0.275121738,0.281741247,0.288307728,0.294821883,0.301284306,0.307695618,0.314056494,0.320367474,0.326629206,0.33284223,0.339007194,0.345124584,0.351195021,0.357219045,0.363197196,0.369130014,0.375018012,0.38086173,0.386661654,0.392418297,0.398132172,0.403803738,0.409433508,0.415021941,0.420569496,0.426076659,0.431543835,0.43697151,0.442360116,0.447710085,0.453021822];    %clarion = [-0.957405555,-0.93371292,-0.910317609,-0.887214735,-0.864399492,-0.841867128,-0.81961308,-0.797632758,-0.775921788,-0.754475769,-0.733290462,-0.712361655,-0.691685298,-0.671257341,-0.651073869,-0.631130994,-0.611424963,-0.591951996,-0.572708529,-0.553690944,-0.534895731,-0.516319461,-0.497958786,-0.479810358,-0.461870937,-0.444137364,-0.426606507,-0.409275261,-0.392140656,-0.375199749,-0.35844957,-0.341887338,-0.325510245,-0.309315537,-0.293300514,-0.277462557,-0.261799047,-0.246307446,-0.23098527,-0.215830008,-0.200839284,-0.186010722,-0.171342,-0.156830823,-0.142474923,-0.128272113,-0.114220233,-0.10031715,-0.086560731,-0.072948978,-0.059479812,-0.046151289,-0.032961438,-0.019908342,-0.006990111,0.005795091,0.0184491,0.030973725,0.043370694,0.055641762,0.06778863,0.079812945,0.091716381,0.103500558,0.115167069,0.12671748,0.138153303,0.14947605,0.16068726,0.171788364,0.18278082,0.193666032,0.204445404,0.215120286,0.225692055,0.236162034,0.246531519,0.256801806,0.266974164,0.277049862,0.287030061,0.29691603,0.30670893,0.316409949,0.326020194,0.335540853,0.344973006,0.354317787,0.363576249,0.372749445,0.381838455,0.390844305,0.399767994,0.408610548,0.417372912,0.426056112,0.434661066,0.443188746,0.45164007,0.460015929,0.468317241,0.47654487,0.484699761,0.492782697,0.500794569,0.508736187,0.516608388,0.524412009,0.532147806,0.539816616,0.547419141,0.554956245,0.562428603,0.569836998,0.577182132,0.584464761,0.591685587,0.598845312,0.605944638,0.612984213,0.619964739];    %phakic = [-0.879523083,-0.856032948,-0.832916655,-0.81016686,-0.787776435,-0.76573836,-0.744045804,-0.722692044,-0.701670546,-0.680974911,-0.660598902,-0.64053639,-0.620781381,-0.601328043,-0.582170652,-0.563303619,-0.544721463,-0.526418811,-0.508390452,-0.490631283,-0.473136255,-0.455900481,-0.438919155,-0.422187579,-0.40570119,-0.389455479,-0.373446018,-0.357668541,-0.342118836,-0.326792745,-0.311686272,-0.296795421,-0.282116358,-0.267645276,-0.253378503,-0.239312367,-0.225443304,-0.211767885,-0.198282654,-0.18498429,-0.171869526,-0.158935149,-0.146178027,-0.133595109,-0.121183344,-0.108939816,-0.096861609,-0.084945888,-0.073189899,-0.061590942,-0.050146317,-0.038853432,-0.027709695,-0.016712649,-0.00585981,0.004851225,0.015422832,0.025857306,0.036156942,0.046323927,0.056360502,0.066268746,0.076050792,0.085708692,0.095244444,0.104660046,0.113957442,0.123138549,0.132205176,0.141159213,0.150002442,0.158736645,0.167363496,0.175884723,0.184302,0.192616974,0.200831211,0.208946304,0.216963792,0.224885214,0.232712028,0.240445692,0.248087664,0.255639348,0.263102094,0.270477306,0.27776628,0.284970339,0.292090752,0.299128788,0.306085716,0.312962697,0.319760946,0.326481651,0.333125946,0.339694965,0.346189815,0.35261163,0.358961409,0.365240259,0.371449206,0.377589276,0.383661441,0.389666673,0.395605998,0.401480307,0.407290545,0.41303763,0.41872248,0.424345959,0.429908931,0.435412287,0.44085681,0.446243391,0.451572786,0.456845832,0.462063285,0.467225955,0.472334544,0.477389862,0.482392584];    %Pt = polyfit(wavelengths, tecnis, 3);    %Pc = polyfit(wavelengths, clarion, 3);    %Pp = polyfit(wavelengths, phakic, 3);        %Ptecnis = polyval(Pt, lambdas/1000);    %Pclarion= polyval(Pc, lambdas/1000);    %Pphakic = polyval(Pp, lambdas/1000);        %LCAs = Ptecnis;        % END ARTHUR        LCAs(2:3,:) = 0;      % convert Rx to a matrix of column power vectors    LCAs = Fourier2Zernike(LCAs, s.r);    % convert F to matrix of col Z-vectors        % Now... in the end we will assemble the PSF stacks and fold them into    % a 3 - channel RGB image. The IQMetrics panel also works with 3    % channels. This is why, for consistency, we need to calculate the LCA    % for these 3 wavelengths.    rgb_LCAs = IndianaEye(s.rgb_lambdas/1000, 1, s.reference_lambda/1000, s.lca_switch, s.qp);    if(size(rgb_LCAs,1) > size(rgb_LCAs,2)), rgb_LCAs = rgb_LCAs'; end    rgb_LCAs(2:3,:) = 0;                            % convert Rx to a matrix of column power vectors    rgb_LCAs = Fourier2Zernike(rgb_LCAs, s.r);        % convert F to matrix of col Z-vectors        % make a CIExyz matrix commensurate with the given wavelengths    % CIExyz = [Nx3] matrix [xbar,ybar,zbar] of CIE color matching functions     % for the N wavelengths in lambda.    lambdas_um = lambdas'/1000;    CIExyz(:,1)=interp1(WXYZ(:,1)/1000, WXYZ(:,2),lambdas_um); % interpolate X    CIExyz(:,2)=interp1(WXYZ(:,1)/1000, WXYZ(:,3),lambdas_um); % interpolate Y    CIExyz(:,3)=interp1(WXYZ(:,1)/1000, WXYZ(:,4),lambdas_um); % interpolate Z    CIExyz(isnan(CIExyz)) = 0;  % replace NaNs with 0 if necessary%% Loop         progress = 0;    progress_total = no_analyses*(no_lambdas+2*no_channels+no_channels);        psf_size = 2^ui_defaults.pupil_bits*ui_defaults.psf_multiplier;        s.dPSF = zeros(psf_size, psf_size, no_channels);    s.dOTF = zeros(psf_size, psf_size, no_channels);    s.nPSF = zeros(psf_size, psf_size, no_channels);                analyses = cell(no_analyses,1);    for analysis_id = 1:no_analyses                data_rgb = cell(no_channels,1);     % this array holds the PSFs resulting from polychromatic mixing, ready to be written as RGB components i.e. in a JPG image        if(strcmp(s.analysis_mode, 'single')), data_spd = cell(no_lambdas,1); end % this array holds the PSFs calculated for each of the lambdas of interest        PSF_stack = zeros(psf_size, psf_size, no_lambdas);                for lambda_idx = 1:no_lambdas                        lambda = lambdas(lambda_idx);            z = s.zernikes;                        progress = progress+1;            show_progress(ui_handles.progress_bar, 100*progress/progress_total);            show_msg(cf, 'Step 1/3 - Calculating PSF stack');                                    z(s.selected_zernike) = s.zernikes(s.selected_zernike) + sweep_diopters(5,analysis_id) + sweep_microns(analysis_id);  % this is the Through-Zernike sweep            z(5) = z(5) + LCAs(5,lambda_idx);                     % take into account the LCA - where plus lens makes eye myopic            z(5) = z(5) + offset(5,1);                            % take into account the device wavelength                        % get the pupil function and use it to compute PSF and OTF            out = zernike2psf(cf, z, s.r, lambda, s);            out.zernike_step = s.analysis_range(analysis_id);            out.lambda_rgb = lambda2rgb(lambda);            out.lambda_idx = lambda_idx;            out.colormap = colorGradient([0 0 0], out.lambda_rgb, 128);            out.lambda = lambda;            out.r = s.r;            out.zernikes = z;                    if(s.polypsf_mode == 1 && strcmp(s.analysis_mode, 'single')), data_spd{lambda_idx} = out; end            PSF_stack(:,:, lambda_idx) = out.PSF;                    end % end lambda loop                analysis = struct();        if(s.polypsf_mode == 1 && strcmp(s.analysis_mode, 'single')), analysis.data_spd = data_spd; end                  PSF_fused = zeros(psf_size, psf_size);        for lambda_idx = 1:no_channels                                    if(no_channels == 1)                out_lambda = s.rgb_lambdas(2);            else                out_lambda = s.rgb_lambdas(lambda_idx);            end                        z = s.zernikes;            z(5) = z(5) + rgb_LCAs(5,lambda_idx);                 % take into account the LCA - where plus lens makes eye myopic            z(5) = z(5) + offset(5,1);                            % take into account the device wavelength                        if(analysis_id == 1)                progress = progress + 1;                show_progress(ui_handles.progress_bar, 100*progress/progress_total);                show_msg(cf, t('Calculating the diffraction-limited PSF'));                                 % Now, since we didn't use zernike2psf.m, instead assembled the PSFs from the stack, we are missing the scaling factors,                % the OTF and diffraction PSF. We need to calculate this information for the output lambdas.                % Thankfully, this function calls the zernike2psf directly.                out = psf_diffraction_psf(cf, z, s.r, out_lambda, s);                s.dPSF(:,:,lambda_idx) = out.PSF;                s.dOTF(:,:,lambda_idx) = out.OTF;                                % the following function will wants a meshgrid in degrees                psf_x = out.psf_x * out.psf_halfwidth / 60;                psf_y = out.psf_y * out.psf_halfwidth / 60;                                s.nPSF(:,:,lambda_idx) = get2DNeuralPSF(psf_x, psf_y);                            end                        progress = progress+1;            show_progress(ui_handles.progress_bar, 100*progress/progress_total);            show_msg(cf, 'Step 2/3 - Calculating poly-PSFs');                 % Assemble a channel (R, G or B) PSF from the stack defined by the slices of the source SPD.            % For original, untouched LNT code see the psf_stack2channel_original.m            PSF = psf_stack2channel(cf, PSF_stack, radiances(:,lambda_idx), CIExyz, lambdas_um);            PSF = PSF(:,:,2);                                                   % The index 2 contains the radiance PSF that we want                        psf_volume = sum(PSF(:));            PSF = PSF./psf_volume;                         PSF_fused = PSF_fused + PSF/max(PSF(:));                        % Fourier transform PSF to get Optical Transfer Function (OTF).            %OTF = fft2(PSF);            %OTF = fftshift(OTF).*out.otf_mask;            %OTF = OTF/max(OTF(:));                           [OTF, otf_x, otf_y] = psf2otf(PSF, out.psf_x, out.psf_y);                        out.PSF = PSF;                                                      % replace the diffraction PSF with the one from the stack            out.OTF = OTF;            out.otf_x = otf_x;            out.otf_y = otf_y;                        %out.zernike_step = s.analysis_range(analysis_id);            out.lambda_rgb = lambda2rgb(out_lambda);            out.lambda_idx = lambda_idx;            out.lambda = out_lambda;            out.colormap = colorGradient([0 0 0], out.lambda_rgb, 128);                        out.zernikes = z;            out.r = s.r;                        data_rgb{lambda_idx} = out;                    end                        % crop and rescale the PSF's        PSF_sizes = zeros(no_channels, 1);        for lambda_idx = 1:no_channels                        progress = progress+1;            percentage = 100*progress/progress_total;            show_progress(ui_handles.progress_bar, percentage);                        out = data_rgb{lambda_idx};                        % Resize PSF to be commensurate with object.            psf_scale = out.psf_resolution/s.pixsize;                           % scale required to make pixel size of PSF = pixel size of object                        if(get(ui_handles.psf_dont_crop, 'Value') == 1)                dim = size(PSF_fused);                %gaussian = gaussian2D(zeros(dim), dim(1)/6, dim/2);                %gaussian = gaussian - min(gaussian(:));                %gaussian = gaussian / max(gaussian(:));                [row, col] = find(ismember(out.PSF, max(out.PSF(:))));                row = floor(size(out.PSF,1)/2 - row);                col = floor(size(out.PSF,2)/2 - col);                PSF_cropped = circshift(out.PSF, [row, col]);                %PSF_cropped = PSF_cropped .* gaussian;                roi = [1, dim(1); 1, dim(2)];            else                [PSF_cropped, roi] = is_polypsf_crop(out.PSF, PSF_fused, s.psf_crop_threshold);            end            PSF_resized = is_psf_resize(PSF_cropped, psf_scale, ui_defaults.psf_rescale_method);                        % Pack everything into the output structure.            out.step_id = analysis_id;            out.zernike_step = s.analysis_range(analysis_id);            out.psf_crop_roi = roi;            out.psf_scale = psf_scale;            out.PSF_cropped = PSF_cropped;            out.PSF_resized = PSF_resized;            %out = rmfield(out, 'OTF'); % save some memory!            out = rmfield(out, 'PSF'); % save some memory!                        PSF_sizes(lambda_idx) = size(PSF_resized,1);                        data_rgb{lambda_idx} = out;        end                %Pad the resized PSFs to have the same size        PSF_sizes = 2^nextpow2(max(PSF_sizes(:)));        for lambda_idx = 1:no_channels                        out = data_rgb{lambda_idx};                          out.PSF_resized = pad2size(out.PSF_resized, PSF_sizes);            out.psf_size = size(out.PSF_resized);                        data_rgb{lambda_idx} = out;        end                analysis.data_rgb = data_rgb;        analyses{analysis_id} = analysis;            end % end analysis loop        show_msg(cf, 'Done. Please Wait...');    show_progress(ui_handles.progress_bar, 0);        if(~strcmp(s.analysis_mode, 'quickview') && ~strcmp(s.analysis_mode, 'batch'))        if(strcmp(s.analysis_type, 'iqm')), analysis_iq_metrics([], [], analyses, s); end        if(strcmp(s.analysis_type, 'mtf')), analysis_mtf_ptf_pf([], [], analyses, s); end        if(strcmp(s.analysis_type, 'sim')), analysis_retinal_sim([], [], analyses, s); end    end        show_msg(cf, 'Ready');    end