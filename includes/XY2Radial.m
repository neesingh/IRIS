function [r,a]=XY2Radial(A,X,Y,option)% XY2Radial - convert f(x,y) to f(r) by collating data over theta%% Usage: [r,a]=XY2Radial(A,X,Y,option)%% Input arguments:%	A = 2D matrix of values of function f%	[X,Y] = mesh that supports A%	option = 0 to use all orientation; =1 to use only 0-180deg (i.e. Y>0)%% Output arguments:%	r = vector of radial distances of each (x,y) point from origin%	a = vector of values of the function f(x,y) = f(r)%% May-01. Modified XY2Radial to collate over 180deg or 360deg.  % In general, OTFs have hermitian symmetry.  Therefore, a radial average of OTF will%  equal the radial average of RE(OTF) since the IM(OTF) will sum to zero.  Thus, the %  imaginary part of OTF will make no contribution to rOTF.  The rOTF will therefore%  be entirely real and even symmetric because RE(Hermitian function) is even symmetric.% To the contrary, the imag part of OTF does contribute to rMTF because MTF=RE(OTF)^2+IM(OTF)^2.% Again, the MTF will be real and even symmetric. Thus rMTF and RE(rOTF) are both real%  and have even symmetry so in principle we only need to sum over 0-180 deg to%  compute rMTF.  However, Xin's program assumes the calculation is over full 360deg.%% LNT 1-Jun-99% LNT 24-May-01 Add option to use half-plane.%% © 1999, 2001 Larry Thibos, Indiana Universityif nargin < 4	option = 0;	% the original algorithmend[TH,R] = cart2pol(X,Y);			% R = a radial support meshM = [TH(:),R(:),A(:)];			% reshape matrices into vectorsM = sortrows(M,2);				% sort by R-valuest = M(:,1);						% vector of polar anglesif option==0			r = M(:,2);					% vector of radial distances	a = M(:,3);					% vector of elements from matrix Aelseif option==1	k = find(t>0);				% indices of angles for which y>0	r = M(k,2);					% vector of radial distances	a = M(k,3);					% vector of elements from matrix Aend% end of function XY2Radial