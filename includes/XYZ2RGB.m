function [RGB, idxlo, idxhi]= XYZ2RGB(cf, XYZ)%XYZ2RGB.m - function to convert XYZ tristimulus values to RGB image values%% input arguments%	XYZ = [r,c,3] matrix of tristimulus values for a colored image. %			For every (r,c) pixel, slice 1=X, slice 2=Y, slice3=Z%% output arguments%	RGB = [r,c,3] matrix of Red, Green, Blue values for display with image%       command. For every (r,c) pixel, slice 1=R, slice 2=G, slice3=B%	idxlo = index into RGB for all values out-of-gamut on low side (i.e. < 0)%	idxhi = index into RGB for all values out-of-gamut on high side (i.e. > 0)%% Base on "A guided tour of color space" by Charles Poynton% 18-Dec-02  LNT. Explored many options.% LNT 3Feb04 - clarified my earlier misunderstandings.  Return to Poynton's%   matrix.% define the transformation matrix by Charles Poynton for Rec 709 primariesXYZ2RGB = [3.240479 -1.537150 -0.498535-0.969256 1.875992 0.0415560.055648 -0.204043 1.057311];% rehape the input matrix so that transformation is a simple matrix multiplication[r,c,s] = size(XYZ);XYZpix = reshape(XYZ,r*c,s);	% each row is a pixel number, cols are X,Y,Z tristimulus valuesRGBpix = XYZ2RGB*XYZpix';		% each column of RGB is a pixel, rows are R,G,B values% RGBpix = SensorToSettings(cal,XYZpix');		% each column of RGB is a pixel number, rows are R,G,B valuesRGB = reshape(RGBpix',r,c,3);	% put pixels back into 3-D matrix format% implement gamut control% NOTE: a better way is to linearly interpolate to white point to get hue-matching%  Could do this with a routine lineXtriangle that finds the nearest%  intersection of the join between spectral locus & white point with the%  three sides of the triangular gamut of an RGB display.% Replacing an out-of-gamut R,G,or B value with 0 or 1 is expedient (makes% the image still renderable) but can be very misleading since the best% replacement value could be very different from zero or one.idxlo=find(RGB < 0); if idxlo > 0	show_msg(cf, [num2str(length(idxlo)),' values out-of-gamut (low)', 'warning']);	RGB(idxlo) = 0;	% gamut control%	RGB(idxlo) = NaN;	% gamut controlendidxhi=find(RGB > 1); if idxhi > 0	show_msg(cf, [num2str(length(idxhi)),' values out-of-gamut (high)', 'warning']);	RGB(idxhi) = 1;	% gamut control%	RGB(idxhi) = NaN;	% gamut controlend% the following are early ramblings:%% define transformation matrix determined by inverting chromaticity coordinates %  obtained from Table 1 of "A guided tour of color space" by Charles Poynton% XYZ2RGB = [0.6892	-0.3269	-0.1060% -0.6932	1.3416	0.0297% 0.0040	-0.0147	0.0763];% define transformation matrix determined by solving over-determined eqns.%  obtained from Table 1 of "A guided tour of color space" by Charles Poynton% XYZ2RGB = [0.5464	0.0745	-0.1070% -0.7549	1.5152	0.0293% -0.1752	0.4893	0.0751];% get transformation matrix from Kaiser and Boynton using Poynton's primaries% XYZ2RGB = [0.6892	-0.3269	-0.1060% -0.6932	1.3416	0.0297% 0.0040	-0.0147	0.0763];% get transformation matrix from Kaiser and Boynton using Kaiser's primaries% XYZ2RGB = [0.7609	-0.3449	-0.1161% -0.7668	1.3649	0.0123% 0.0059	-0.0201	0.1038];% from Brainard cal.M_linear_device% XYZ2RGB = [0.0721   -0.0319   -0.0112%    -0.0276    0.0503    0.0009%     0.0016   -0.0047    0.0191];% from makeXYZ2RGB using Rhea Eskew's suggested luminance values (this is the version used%	prior to Feb2004% XYZ2RGB = [2.1096	-0.9087	-0.2552% -1.1676	2.1884	0.0111% 0.0577	-0.2809	1.2432];