function [ analyses, s ] = analysis_simple( ~, ~, s )% Parts based upon the Fourier Optics Calculator © 2004 Larry Thibos, Indiana University% Parts based upon the w-Tool © 2003 D. R. Iskander%% Adapted and developed by Matt Jaskulski, University of Murcia © 2015%%   zernikes        [um]%   r               [mm]%   mode            [single/through-focus]%   type            [mtf/iqm/sim]%%   To-do's and developer's notes:%   1. mode = 2 where 'bifocal wavefronts' are calculated is not implemented. In the original FOC the RESULTS structure is not%       initialized and so one has to press OK in the GUI to initialize it or else the program will crash and burn. I'm leaving it for now.%       Re-implement the whole thing later!%   2. plan is to duplicate zernike2psf functionality by either giving it a new front-end that can handle vanMeeteren's input %       or use one of Yizhong Wang's old programs to reconstruct the wavefront and hand it off as a Case 3 calculation. %   3. Obliquely oriented pupil axes are not allowed yet.%   4. From zernike2psf.m: Strategic issue: Should we shift the PSF onto it's own center before computing OTF?%       Test case is the diffraction-limited system with prism. We let the  calling program decide. For example, QualityMetrics omits prism from the%       Zernike vector before handing it off to zernike2psf. This should make the PSF nominally centered, so OTF should not have large linear phase shifts.%   5. Consider always using mask90 to avoid edge effects in zernike2psf. Or scrap it.%   6. The script to rescale zernikes to correspond to a different radius only works up to the 7th order. See zernike_rescale.m%   7. TO BE REIMPLEMENTED - At the request of Arthur and Pete, allow input parameter "a" to be a matrix defining the wavefront aberration function,%       rather than a vector of Zernike coeffs. Tested with script test_Zc2psfV2.%   8. TO BE VERIFIED Add capability to compute geometrical optics approximation to the PSF using spot diagrams.  Verified this works with Zernike inputs %       and wavefront inputs using test_Zc2psfV2.m and a defocused eye. Also verified that changing test wavelengths from 0.6 to 0.4, leaving%       reflambda fixed at 0.4, gave commensurate GOpsfs (i.e. sample points are at the same locations) and form of spot diagram was unaffected.%       This is one advantage of the GOpsf: it is independent of wavelength at this stage. When ConvertWavelength is installed to adjust the wavefront%       for wavelength, then a small effect is expected on GOpsf. Next step is to make the GOpsf an optional substitute for the standard%       wave-optics PSF, and to compute OTF from it. This should give an acceptable result for large aberrations, and may extend the useful %       dynamic range of the metrics.%   9. Think about PSF's drifting%                               cell array       structure%                           from 1 to no_steps%   IS's data structure:        ANALYSES    =>   ANALYSIS %                                                   .rgb_data - 1 or 3 element cell array with R, G, B PSF's, their convolutions, etc%                                                   .spd_data - multi element cell array with PSF's corresponding to each of the sampled lambdas    cf = s.cf;    show_msg(cf, t('Working, Please Wait...'));        ui_handles = getappdata(cf, 'ui_handles');      % all of the uicontrols of the launcher    ui_defaults= getappdata(cf, 'ui_defaults');     % basic settings available via the settings panel        target_image = get(ui_handles.target_image, 'UserData');    original_image=get(ui_handles.original_image, 'UserData');        % figure out the lambda if the image is monochrome        % if the user loaded a monochrome image, use the device lambda    if(size(original_image,3) == 1 || strcmp(s.analysis_mode, 'quickview'))        s.rgb_lambdas = s.device_lambda;    elseif(size(target_image,3) == 1)        channel_tabs = get(ui_handles.target_image, 'Parent');        channel_tabs = get(channel_tabs, 'Parent');        selected_channel = channel_tabs.SelectedTab;        selected_channel = str2double((get(selected_channel, 'Tag')));        size(s.rgb_lambdas)        s.rgb_lambdas = s.rgb_lambdas(selected_channel);    end           if(s.selected_zernike == 5)        s.selected_zernike_value = microns2diopters(s.selected_zernike_value, s.r);                sweep_diopters = s.analysis_range;                       % a vector of spherical powers [D]        sweep_diopters(2:3,:) = 0;                               % add two rows of zeros        sweep_diopters = -Fourier2Zernike(sweep_diopters, s.r);  % convert spherical refraction to Zernikes        sweep_microns = zeros(1, length(s.analysis_range));    else        sweep_diopters = zeros(5, length(s.analysis_range));     % just a zero matrix        sweep_microns = s.analysis_range;    end        % compute the offset caused by the device lambda / reference lambda difference                                                          offset = IndianaEye(s.device_lambda/1000, 1, s.reference_lambda/1000, s.lca_switch, s.qp) + s.offset;    offset(2:3,:) = 0;                                    % convert Rx to a matrix of column power vectors    offset = Fourier2Zernike(offset, s.r);                % convert F to matrix of col Z-vectors        % compute vector of refractive errors for longitudinal chromatic aberration    LCAs = IndianaEye(s.rgb_lambdas/1000, 1, s.reference_lambda/1000, s.lca_switch, s.qp);    LCAs = LCAs * s.lca_multiplier;    if(size(LCAs,1) > size(LCAs,2)), LCAs = LCAs'; end    LCAs(2:3,:) = 0;                            % convert Rx to a matrix of column power vectors    LCAs = Fourier2Zernike(LCAs, s.r);          % convert F to matrix of col Z-vectors        % In the original FOC, line 115 of TfocusFourierOptics.m there was a distinction between the above method    % (Fourier2Zernike) and the bifocal wavefront created by BifocalFourierOptics (BFOC supplies bifocal wavefronts).    % Might be worth re-implementing but I'm missing that code.%% Simple/Crude Poly PSF Calculation    no_channels = length(s.rgb_lambdas);    no_analyses= length(s.analysis_range);         progress = 0;    progress_total = no_analyses*2*no_channels+no_channels;    psf_size = 2^ui_defaults.pupil_bits*ui_defaults.psf_multiplier;        s.dPSF = zeros(psf_size, psf_size, no_channels);    s.dOTF = zeros(psf_size, psf_size, no_channels);    s.nPSF = zeros(psf_size, psf_size, no_channels);        analyses = cell(no_analyses,1);    for analysis_id = 1:no_analyses                  data_rgb = cell(no_channels,1);        PSF_fused = zeros(psf_size, psf_size);        for lambda_idx = 1:no_channels                        lambda = s.rgb_lambdas(lambda_idx);            z = s.zernikes;                        if(analysis_id == 1)                progress = progress + 1;                percentage = 100*progress/progress_total;                show_progress(ui_handles.progress_bar, percentage);                show_msg(cf, t('Calculating the diffraction-limited PSF'));                                 out = psf_diffraction_psf(cf, z, s.r, lambda, s);                s.dPSF(:,:,lambda_idx) = out.PSF;                s.dOTF(:,:,lambda_idx) = out.OTF;                                % the following function will wants a meshgrid in degrees                psf_x = out.psf_x * out.psf_halfwidth / 60;                psf_y = out.psf_y * out.psf_halfwidth / 60;                                s.nPSF(:,:,lambda_idx) = get2DNeuralPSF(psf_x, psf_y);            end                        progress = progress + 1;            percentage = 100*progress/progress_total;            show_progress(ui_handles.progress_bar, percentage);            show_msg(cf, t('Calculating PSF'));                        z(s.selected_zernike) = s.zernikes(s.selected_zernike) + sweep_diopters(5,analysis_id) + sweep_microns(analysis_id);  % this is the Through-Zernike sweep            z(5) = z(5) + LCAs(5,lambda_idx);                     % take into account the LCA - where plus lens makes eye myopic            z(5) = z(5) + offset(5,1);                            % take into account the device wavelength            % Note: a more complete solution would use ConvertWavelength to change all Zernike coeffs of the eye (incl. Z2,3,5) to wavelength.            % I'm missing this file, MJ.                        % Note on signs:             % + h. tilt pushes PSF to left, pos. h. coma makes a PSF with head to right, tails to left            % + v. tilt pushes PSF down, pos. v. coma makes a PSF with head up, tails down like a rocketship            % Note on prism:            % Vert. slope of wavefront in normalized pupil coordinates = 2*a(2)=2*RMS            % Offset of PSF (milliradians) from origin = -2*a(2)/pupilradius(mm)            out = zernike2psf(cf, z, s.r, lambda, s);         % sweet, retouched file full of goodness            out.zernikes = z;            out.r = s.r;                        PSF_fused = PSF_fused + out.PSF/max(out.PSF(:));% unless I figure out a more elegant way, this PSF is just used for cropping                        data_rgb{lambda_idx} = out;        end                % crop and rescale the PSF's        PSF_sizes = zeros(no_channels, 1);        for lambda_idx = 1:no_channels            lambda = s.rgb_lambdas(lambda_idx);            out = data_rgb{lambda_idx};                        progress = progress + 1;            percentage = 100*progress/progress_total;            show_progress(ui_handles.progress_bar, percentage);                        if(s.calculate_psf == 1)                % step 2: resize PSF to be commensurate with object. better not to crop. Let the user use Matlab's Zoom Tools                psf_scale = out.psf_resolution/s.pixsize;                   % scale required to make pixel size of PSF = pixel size of object                if(get(ui_handles.psf_dont_crop, 'Value') == 1)                                        dim = size(PSF_fused);                    gaussian = gaussian2D(zeros(dim), dim(1)/6, dim/2);                    gaussian = gaussian - min(gaussian(:));                    gaussian = gaussian / max(gaussian(:));                                        [row, col] = find(ismember(out.PSF, max(out.PSF(:))));                    row = floor(size(out.PSF,1)/2 - row);                    col = floor(size(out.PSF,2)/2 - col);                    PSF_cropped = circshift(out.PSF, [row, col]);                                        PSF_cropped = PSF_cropped .* gaussian;                    roi = [1, dim(1); 1, dim(2)];                                    else                    [PSF_cropped, roi] = is_polypsf_crop(out.PSF, PSF_fused, s.psf_crop_threshold);                end                                PSF_resized = is_psf_resize(PSF_cropped, psf_scale, ui_defaults.psf_rescale_method);                out.psf_crop_roi = roi;                out.psf_scale = psf_scale;                out.PSF_cropped = PSF_cropped;                out.PSF_resized = PSF_resized;                out = rmfield(out, 'PSF'); % save some memory!                %out = rmfield(out, 'OTF'); % save some memory!                                PSF_sizes(lambda_idx) = size(PSF_resized,1);            end                        [~, real_lambda_idx] = min(abs(ui_defaults.lambdas - lambda));                        out.step_id = analysis_id;            out.zernike_step = s.analysis_range(analysis_id);            out.lambda_rgb = lambda2rgb(lambda);            out.lambda_idx = real_lambda_idx;            out.lambda = lambda;            out.colormap = colorGradient([0 0 0], out.lambda_rgb, 128);                data_rgb{lambda_idx} = out;        end % end lambda loop                if(s.calculate_psf == 1)            %Pad the resized PSFs to have the same size (each pixel already            %subtends the same angle)            PSF_sizes = 2^nextpow2(max(PSF_sizes(:)));            for lambda_idx = 1:no_channels                out = data_rgb{lambda_idx};                  out.PSF_resized = pad2size(out.PSF_resized, PSF_sizes);                out.psf_size = size(out.PSF_resized);                data_rgb{lambda_idx} = out;            end        end                analysis = struct();        analysis.data_rgb = data_rgb;                analyses{analysis_id} = analysis;            end % end analysis loop        show_msg(cf, 'Done. Please Wait...');    show_progress(ui_handles.progress_bar, 0);        if(~strcmp(s.analysis_mode, 'quickview') && ~strcmp(s.analysis_mode, 'batch'))        if(strcmp(s.analysis_type, 'iqm')), analysis_iq_metrics([], [], analyses, s); end        if(strcmp(s.analysis_type, 'mtf')), analysis_mtf_ptf_pf([], [], analyses, s); end        if(strcmp(s.analysis_type, 'sim')), analysis_retinal_sim([], [], analyses, s); end    end        show_msg(cf, 'Ready');    end